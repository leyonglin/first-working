tomcat调试：
jstack,jmap,jinfo,jstat,jps


gc(garbage collection)：垃圾回收（内存）
Minor GC：从年轻代空间（包括 Eden 和 Survivor 区域）回收内存
Major GC：是清理老年代。
Full  GC：是清理整个堆空间—包括年轻代和老年代。
JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。
线程堆(heap)栈(stack)也称线程调用堆栈，是虚拟机中所有线程的运行状态（包括锁）的一个瞬间快照,
堆栈是一种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。一端是固定的，另一端是浮动的。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。
栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 堆是一个运行时数据区，由垃圾回收来负责。
栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共 享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要 在运行时动态分配内存，存取速度较慢。
要点对比：指令队列，先进先出（FIFO—first in first out）。堆栈，先进后出 (FILO—First-In/Last-Out)。
输出堆栈：Java虚拟机提供了线程转储（thread dump）的后门，通过这个后门可以把线程堆栈打印出来


1，在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。
2，紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，
3，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。
   年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。
4，经过这次GC后，Eden区和From区已经被清空。
   这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。
   不管怎样，都会保证名为To的Survivor区域是空的。
5，Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。