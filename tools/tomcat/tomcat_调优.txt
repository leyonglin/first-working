tomcat调试：
jstack,jmap,jinfo,jstat,jps

gc(garbage collection)：垃圾回收（内存）
Minor GC：从年轻代空间（包括 Eden 和 Survivor 区域）回收内存，一般占据堆的1/3空间，会频繁触发MinorGC进行垃圾回收。当Eden区内存不够的时候就会触发MinorGC
Major GC：是清理老年代(标记—清除算法)。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间,耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。
Full  GC：是清理整个堆空间—包括年轻代和老年代。
Permsize：永久代，内存的永久保存区域，主要存放Class和Meta（元数据）的信息。默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中. 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制
元空间：Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间并不在虚拟机中，而是使用本地内存。
JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。


HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。
线程堆(heap)栈(stack)也称线程调用堆栈，是虚拟机中所有线程的运行状态（包括锁）的一个瞬间快照,
堆栈是一种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。一端是固定的，另一端是浮动的。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。
栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 堆是一个运行时数据区，由垃圾回收来负责。
栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要 在运行时动态分配内存，存取速度较慢。
要点对比：指令队列，先进先出（FIFO—first in first out）。堆栈，先进后出 (FILO—First-In/Last-Out)。
输出堆栈：Java虚拟机提供了线程转储（thread dump）的后门，通过这个后门可以把线程堆栈打印出来
堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。
栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。

栈区主要存放编译器在需要的时候自动分配，在不需要的时候自动销毁的变量。主要是局部变量和函数的参数等，在函数调用和传参的时候，编译器为局部变量或形参开辟空间
堆区是一个动态的存储区域，使用库函数malloc()和free()，和操作符new和delete以及一些相关变量来进行分配和回收，
内存管理中的“堆栈”其实是分为堆(heap)和栈(stack)的，以引用变量为例，引用变量本身存储在栈中，引用变量指向的值存储在堆中。
数据结构中的一般称“栈(stack)”，是一种后进先出的数据结构。它是一种概念，或者说是一种逻辑技术，与语言、平台无关。

1，在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。
2，紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，
3，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向(一般是15)。
   年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。
4，经过这次GC后，Eden区和From区已经被清空。
   这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。
   不管怎样，都会保证名为To的Survivor区域是空的。
5，Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。


jstack -l  pid  > /tmp/jvm.dump                         导出进程堆栈信息
top -H -p pid  或 ps -mp pid -o pid,THREAD,tid,time    查出进程内占用cpu高的线程pid                                                                                   #查出进程内占用cpu高的线程pid