tomcat调试：
jstack,jmap,jinfo,jstat,jps

gc(garbage collection)：垃圾回收（内存）
Minor GC：从年轻代空间（包括 Eden 和 Survivor(From To)区域）回收内存，一般占据堆的1/3空间，会频繁触发MinorGC进行垃圾回收。当Eden区内存不够的时候就会触发MinorGC
Major GC：是清理老年代(标记—清除算法)。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间,耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。
Full  GC：是清理整个堆空间—包括年轻代和老年代。
Permsize：永久代，内存的永久保存区域，主要存放Class和Meta（元数据）的信息。默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中. 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制
元空间：Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间并不在虚拟机中，而是使用本地内存。
JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。


HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。
线程堆(heap)栈(stack)也称线程调用堆栈，是虚拟机中所有线程的运行状态（包括锁）的一个瞬间快照,
堆栈是一种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。一端是固定的，另一端是浮动的。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。
栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 堆是一个运行时数据区，由垃圾回收来负责。
栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要 在运行时动态分配内存，存取速度较慢。
要点对比：指令队列，先进先出（FIFO—first in first out）。堆栈，先进后出 (FILO—First-In/Last-Out)。
输出堆栈：Java虚拟机提供了线程转储（thread dump）的后门，通过这个后门可以把线程堆栈打印出来
堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。
栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。

栈区主要存放编译器在需要的时候自动分配，在不需要的时候自动销毁的变量。主要是局部变量和函数的参数等，在函数调用和传参的时候，编译器为局部变量或形参开辟空间
堆区是一个动态的存储区域，使用库函数malloc()和free()，和操作符new和delete以及一些相关变量来进行分配和回收，
内存管理中的“堆栈”其实是分为堆(heap)和栈(stack)的，以引用变量为例，引用变量本身存储在栈中，引用变量指向的值存储在堆中。
数据结构中的一般称“栈(stack)”，是一种后进先出的数据结构。它是一种概念，或者说是一种逻辑技术，与语言、平台无关。

1，在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。
2，紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，
3，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向(一般是15)。
   年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。
4，经过这次GC后，Eden区和From区已经被清空。
   这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。
   不管怎样，都会保证名为To的Survivor区域是空的。
5，Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。


jstack -l  pid  > /tmp/jvm.dump                         导出进程堆栈信息
top -H -p pid  或 ps -mp pid -o pid,THREAD,tid,time     查出进程内占用cpu高的线程pid     



https://www.jianshu.com/p/d8492e748c57   //   https://www.bilibili.com/video/av44880257?p=2

jvm内存结构规范：
java源代码文件*.java -- （编译器） -- java字节码文件*.class --- 类加载器 --- 内存区域/运行时数据区(方法区，堆，虚拟机栈 本地方法栈 程序计数器) --- 1.执行器-->2.本地方法接口---本地方法库


1.类文件结构(java字节码文件*.class)：
     u1，u2，u4，u8  分别代表了1、2、4、8个字节的无符号数
     ClassFile { 
         u4 magic;  // 魔法数字，表明当前文件是.class文件，固定0xCAFEBABE(Java类文件)
         u2 minor_version; // 分别为Class文件的副版本和主版本
         u2 major_version; 
         u2 constant_pool_count; // 常量池计数
         cp_info constant_pool[constant_pool_count-1];  // 常量池内容
         u2 access_flags; // 类访问标识
         u2 this_class; // 当前类
         u2 super_class; // 父类
         u2 interfaces_count; // 实现的接口数
         u2 interfaces[interfaces_count]; // 实现接口信息
         u2 fields_count; // 字段数量
         field_info fields[fields_count]; // 包含的字段信息 
         u2 methods_count; // 方法数量
         method_info methods[methods_count]; // 包含的方法信息
         u2 attributes_count;  // 属性数量
         attribute_info attributes[attributes_count]; // 各种属性
     }
     
     类名不超过256
     class文件包括：虚拟机指令  符号表  其他辅助信息  
          数据结构：无符号数(正整数)    表*_info(表结构嵌套) 
     访问控制标志(access flags)：
     
     class文件结构---常量池(主次版本号之后就是常量池入口，代表class文件中的仓库资源)：主要存放两大类常量：
     字面量：int a=3;(=号右边的东西)
     符号引用：类和接口的全限定名(绝对路径)   字段的名称和描述符   方法的名称和描述符
     
     init：实例化初始方法
     clinit：类和接口的初始化

2.java虚拟机类加载机制：加载loading---连接linking(验证verification--准备preparation---解析resolution)---初始化initialization---使用using---卸载unloading
     双亲委任JVM类加载机制：安全，保证代码不会被篡改


3.java虚拟机运行时数据区：方法区，堆，虚拟机栈 本地方法栈 程序计数器
     方法区存放的数据(javap -verbose TestClass.class)：类的描述，常量池(常量，静态变量)，jit即时编译编译器,编译成机器指令 (线程共享)方法区无法满足内存分配需求时OOM
     堆heap存放的数据((new)实例化)：类的实例：对象 (线程共享)
     栈区：执行/业务逻辑(线程私有)，一个栈帧 = 调用一次函数    一个main()函数调用(可以嵌套函数) = 一个栈     随着栈帧的弹出(返回)而消失
	    虚拟机栈： 分配基本类型和自定义对象(堆)的引用(局部变量表，操作数栈，动态连接/方法返回地址)
		本地方法栈 ：为了native方法的调用/执行/退出    c/c++本地方法库
		程序计数器(PC counter)：存放下一条指令的地址(cpu--->指令寄存器<-----程序计数器
局部变量：8种类型+引用，是一个函数里面的变量           
FILO：先进后出---栈      栈帧：先进(栈底)后进(栈顶)
FIFO：先进先出---队列

4.java垃圾回收 
  针对方法区和堆区，栈是线程私有数据，不进行回收
  1.引用计数：给对象添加一个引用计数器，每当堆这个对象进行一次引用，计数器就加1，每当引用失效的时候，引用计数器就减，当这个引用计数器等于0的时候，表示这个对象不会再被引用
  2.可达性分析：判断对象是否被引用
强引用：有用且必须，代码中有明显的new object()这类引用，只要引用还在，垃圾回收器就不会回收它，内存不够，则会报OOM异常
软引用：有用非必须，内存够用存在，内存不够用则会被回收
弱引用：非必须对象，只能生存到下次垃圾收集时
虚引用：无用对象，垃圾收集时会收到系统通知
  标记-清除算法：效率不高且碎片化(大对象找不到连续的空间报OOM)(老年代)
  复制算法：只能使用一半内存，内存利用率低
  标记整理算法：标记回收后，再整理碎片(老年代)
  分代收集算法：新生代(Eden+From+To)
保守GC:
非保守式的GC
精确式GC   hotspot---> oopmap记录在安全点safepoint的时候可以回收那些数据
stw(stop the world)：停止所有线程
抢先式中断：主动中断，没有执行到指定安全点的用户线程，继续执行直到safepoint
主动式中断：当gc需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，然后让用户线程自己去检查，然后中断
  垃圾回收器参数：-XX:+Use<垃圾回收器名称>GC	
  serial(串行)收集器：单线程，新生代和老年代都会STW    适合场景：用户的桌面应用场景
  serial old:
  parnew(parallelnew)收集器：只对新生代串行收集，老年代单线程
  parnew old(并行):新生代和老年代都是用多线程
  parallel scavenge收集器:用户可以控制垃圾回收时间    适合场景：后台计算不需要太多交互
    吞吐量：用户代码执行时间/(用户代码执行时间+gc时间)
	吞吐量99%：用户代码执行时间99%，1%GC时间
  concurrent mark sweep(CMS)收集器：














                                                                       
