
01： 对象和类

面向过程编程：基本单位是函数
面向对象编程object-oriented programming：一种将一切看作物体的思维
面向对象：把一切看成对象(实例)，用各种对象之间的关系来描述事务
	对象的特征：1.对象有很多的属性    2.对象有很多的行为(动作)
类：拥有相同属性和行为的对象分为一组，即为一个类。是用来描述对象的工具，用类可以创建此类的对象(实例)
	类的创建语句class语句
		语法：
			class 类名(继承列表):
				'''文档字符串'''
				实例方法定义
				类变量定义
				类方法定义(@classmethod)
				静态方法定义(@staticmethod)
		作用：1.创建一个类   2.用于描述对象的行为和属性    3.用于创建此类的一个或多个对象(实例)
			说明：1.类名必须为标识符(建议首字母大写)    2.类名实质上就是变量，它绑定一个类
		
	构造函数(对象)
		构造函数调用表达式：
			类名([创建传参列表])
		作用：创建这个类的实例对象，并返回此实例对象的引用关系
		说明：实例有自己的作用域和名字空间，可以为该实例添加实例变量(属性)
			  实例可以调用类方法和实例方法
			  实例可以访问类变量和实例变量
	对象有两种特征: 1.实例属性   2.实例方法(描述行为 )		  
	实例方法(method)
		语法：
			class 类名(继承列表):
				def 实例方法名(self, 形参名1, 形参名2, ...):
					'方法文档字符串'
					语句块
		作用：用于描述一个对象的行为，让此类型的全部对象都拥有相同的行为
		说明：实例方法实质是函数，是定义在类内的函数
			  实例方法至少有一个形参，第一个形参用来绑定调用这个方法的实例，一般命名为'self'
		实例方法的调用语句：
			实例.实例方法名(调用传参)     #实例方法名 = 类内的函数名
			或
			类名.实例方法名(实例,调用传参)
	实例属性attribute(实例变量)：每个实例可以有自己的变量用来保存对象自己的数据，称为实例变量(属性)
		语法：
			实例.属性名
		赋值规则同变量的赋值规则：
			1.首次为属性赋值则创建此属性    
			2.再次为属性赋值则改变属性的绑定关系
		作用：记录每个对象自身的数据
		实例：
			class Dog:                                                   #创建类
				def eat(self, food):                                     #创建实例方法(共性),self被赋值为实例对象
					print(self.color, '的', self.kinds, '正在吃', food)   #可以调用实例属性
					self.food=food                                       #实例属性赋值(个性)，保存对象自己的数据，该属性由dog1.eat('骨头')传参执行后赋值的，和dog1.kinds='二哈'作用是一样的
				def show_food(self):
					# print(self.color, '的', self.kinds, '正在吃1', food) #会失败，显示food未定义。kinds和color不会报错，在外面已经进行实例属性赋值了  
					print(self.color, '的', self.kinds, '上次吃的是', self.food)
			
			dog1=Dog()                                                   #创建实例对象
			dog1.kinds='二哈'                                            #实例属性赋值
			dog1.color='白色'                                            #实例属性赋值
			print(dog1.color, '的', dog1.kinds)                          
			dog1.eat('骨头')                                             #传递参数，并通过self.food=food 进行实例属性赋值       
			dog1.show_food()                                             

	del 语句：可以删除对象(实例)的属性
		语法：del 对象.实例变量名
		1.删除变量 2.删除列表的元素   3.删除字典的键   4.删除对象的属性

	初始化方法：对新创建的对象添加属性
		语法格式：
			class 类名(继承列表):
				def __init__(self, [形参列表]):     #color为形参
					语句块                          #self.color=color初始化实例赋值
		说明：
			1.初始化方法名必须为'__init__'不可改变
			2.初始化方法会在构造函数创建实例后自动调用，且将实例自身通过第一个参数self传入__init__方法
			3.构造函数的实参将通过__init__方法的参数列表传入到__init__方法中
			4.实例化方法内如果需要return语句返回，则只能返回None
	析构方法：
		class 类名(继承列表):
			def __def__(self):
				语句块
		析构方法在对象被销毁(实例绑定关系改变或实例被删除或程序退出)时被自动调用，可以释放资源(python语言建议不要在对象销毁时做任何事情)
					
	预置实例属性：
		__dict__属性 ：绑定一个存储此实例自身变量字典(存放实例属性)

		__class__属性：绑定创建此实例的类
			作用：可以借助此属性来访问创建此实例的类

	用于类的函数：
		isinstance(obj,class_or_tuple) 返回这个对象obj是否是某个类的对象或者某些类中的一个类的对象，如果是则返回True，否则返回False
		type(obj)  返回对象的类型
			实例:isinstance(3.14, (int, Dog, float))
				 type(3.14)("12.34")      




02： 函数重写 str/repr函数重写示例

变量可以使用dir()查看
类变量是类的属性，此属性属于类，不属于此类的实例
	作用：通常用来存储该类创建对象的共有属性(类里面的不经初始化方法且非函数全局变量)
	说明：1.类变量可以通过该类直接访问,可以通过该访问方式(第一种和第三种)修改    2.类变量可以通过类的实例直接访问   3.类变量可以通过此类的对象__class_属性间接访问
	示例：
		class Human:
			man_count = 0          			 #类变量，可以被方法调用
			def __init__(self)
				self.__class__.man_count +=1  	 #可被调用
		h1 = Human()
		h1.man_count=1000          			 #为示例添加示例属性，不会更改类变量，直接调用则会调用类变量
		print(Human.man_count)     			 #直接访问类变量，类似 模块名.变量名
		h1.__class__.man_count +=1 			 #改变类变量
		
类的文档字符串：1.可以通过help()查看   2.绑定在类的__doc__属性上   3.第一个没有赋值给任何变量的字符串为类的文档字符串

类的__slots__列表：
		1.限定一个类创建的实例只能有固定的属性(实例变量)
		2.不允许对象添加列表以外的实例属性(实例变量)
		3.防止用户因错写属性名而发生程序错误
	说明：__slots__属性绑定一个字符串列表
		含有__slots__属性的类所创建的实例对象没有__dict__属性，即此实例不用字典来存储对象的实例属性	 
	示例：  
		class Human:
			__slots__=[变量列表]      #如果出现其他变量，会报错

类方法:类方法是用于描述类的行为的方法，类方法属于类，不属于类的实例对象，使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用
	说明：
		类方法需要使用@classmethod装饰器定义，目的用来操作类变量
		类方法至少有一个形参，第一个形参用于绑定类，约定写为'cls'
		类和该类的实例都可以调用类方法
		类方法不能访问此类创建的对象的实例属性
	示例：
		class A:
			v=0                    #类变量(属性)
			@classmethod
			def get_v(cls):
				return cls.v         #用cls访问类变量v
			@classmethod
			def set_v(cls,a):
				cls.v=a
				# print(cls.color)   #类方法不能访问此类创建的对象的实例属性
		print('A.v=', A.get_v())   #调用类方法得到类变量的值
		A.set_v(100)               #使用方法调用改变类变量的值
		print('A.v=', A.get_v())
		# a.color = '白色'
	
	静态方法@staticmethod:
		静态方法是定义在类的内部的普通函数，此函数的作用域是类的内部
		说明：
			静态方法需要使用@staticmethod装饰器定义
			静态方法与普通函数定义相同，不需要传入self示例参数和cls类参数
			静态方法只能凭借该类或类创建的实例调用
			静态方法不能(也不需要)访问类变量和实例变量
	实例：
		class A:
			@staticmethod            #静态方法
			def myadd(a, b):         #第一个形参不用是self,就像普通函数一样
				return a+b
		print(A.myadd(100,200))      #调用方式：类名.函数()
		a=A()
		print(a.myadd(1,20))


继承inheritance 和派生derived:方向不同
	1.继承是从已有的类中派生出新的类，新类具有原类的数据属性和行为，并能拓展新的行为
		继承的目的是延续旧类的功能
	2.派生类就是从一个已有的类中衍生出新的类，在新类的基础上添加新的属性和行为	
		派生的目的是在旧类的基础上改变原有的功能
	名词：
		基类(base class)/超类(super class)/父类(father class)
		派生类(derived class)/子类(child class)
	单继承：
		语法：
			class 类名(基类名):
				  语句块
	说明：单继承是指派生类有一个基类衍生出来的新类
	示例：
		class Human:
			def say(self, what):
				print("说", what)
		class Student(Human):
			def study(self, subject):
				print("正在学习", subject)
		h1=Student()
		h1.say("good")
		h1.study("python")
	继承派生机制的作用：
		1.可以将一些共有功能加上基类中，实现代码共享
		2.在不改变基类的基础上改变原有的功能
	继承说明：
		python3任何类都直接或间接的继承自object类，object类是一切类的超类
	类的__base__属性：用来记录此类的基类
	python内建的类：help(__builtins__)

覆盖override:
	指在有继承关系的类中，子类中实现了与基类同名的方法，在子类的实例调用该方法时，实际调用的是子类中的覆盖版本
	super函数：
		super(cls, obj)返回绑定超类的实例(obj必须为cls类型的实例)
		super()返回绑定超类的实例，等同于super(__class__,实例方法的第一个参数，必须在方法内调用)
		作用：借助super()返回的实例间接调用父类的覆盖方法
		示例：
			class A:
				def work(self):
					print("A.work被调用")
			class B(A):
				def work(self):
					print("B.work被调用!!!")
				def super_work(self):
					self.work()                  #调用B类方法
					super(B, self).work()        #调用方法
					super().work()               #必须在方法内调用
			
			
			b=B()
			b.work()              #B被调用
			super(B, b).work()    #A.work被调用

显示调用基类的初始化方法：
	当子类中实现了__init__方法，基类的构造方法并不会被调用，此时需要显示调用
	示例：
		class Human:
			def __init__(self, n, a):
				self.name = n
				self.age = a
				print("Human类的初始化方法被调用...")
			def infos(self):
				print("姓名", self.name)
				print("年龄", self.age)
		class Student(Human):
			def __init__(self, n, a, s=0):                #s1=Student('张飞', 15, 80)调用该初始化方法，默认覆盖父类同名方法
				super(Student, self).__init__(n,a)        #将n，a传到父类初始化方法并调用
				self.score=s
				print("Student的初始化方法被调用...")
		
		s1=Student('张飞', 15, 80)
		s1.infos()




03： 继承(inheritance) 和 派生(derived) 封装 多态

用于类的函数：
	issubclass(cls, class_or_tuple)判断一个类cls是否继承自其它的类class_or_tuple，如果此类cls是class或tuple中一个派生子类则返回True，否则返回False

封装enclosure：
	指隐藏类的实现细节，让使用者不关心这些细节
	封装的目的是让使用者通过尽可能少的方法(属性)操作对象
私有属性和方法
	python类中，以双下划线('__')开头，不以双下划线结尾的标识符为私有成员，私有成员只能使用该类的方法进行访问和修改
	1.以__开头的属性为私有属性    2.以__开头的方法为私有方法
	实例：
		class A:
			def __init__(self):
				self.__p1 = 100     #私有属性
				# self._p2 = 200      #不是私有属性
				# self.__p3__ = 300   #不是私有属性
			def show_info(self):
				print(self.__p1)    #此对象的实例方法可以访问和修改私有属性
				self.__m()            #调用私有方法
			def __m(self):
				print("A类对象的__m方法被调用")			
		a = A()
		a.show_info()     #只能使用该类的方法进行访问和修改
		# print(a.__p1)   #外部不允许访问私有属性
		# print(a._p2)    #可以访问
		# print(a.__p3__) #可以访问
		# a.__m()           #无法直接访问私有方法
	注意：python的封装是假的封装(模拟的封装)  --->  a._A__p1  可以访问到(查看dir(obj))

多态polymorphic:
	指在有继承/派生关系的类中，调用基类对象的方法，实际能调用子类的覆盖方法的现象叫多态
	状态：静态(编译时状态)   动态(运行时状态)
	说明：1.多态调用的方法与对象相关，不写类型相关   2.python全部对象都只有"运行时状态(动态)"，没有c++语言里的编译时状态(静态)
	示例：
		class Shape:
			def draw(self):
				print("Shape的draw()被调用")
		class Point(Shape):
			def draw(self):
				print('正在画一个点！')
		class Circle(Point):
			def draw(self):
				print('正在画一个圆！')
		def my_draw(s):
			s.draw()     #c++等语言有静态(编译时状态)，编译时会根据s的类型调用相应方法，python是弱类型的，因此只能在运行时，根据对象才能决定调用那个方法
		
		s1=Circle()
		my_draw(s1)
		
面向对象编程语言的特征： 继承   封装   多态

多继承：
	指一个子类继承自两个或两个以上的基类
	语法: class 类名(基类名1, 基类名2, ...)
	说明：
		一个子类同时继承自多个父类，父类中的方法可以同时被继承下来
		如果两个父类中有同名的方法，而在子类中又没有覆盖此方法时，调用结果难以确定
	多继承的MRO(Method Resolution Order)
		python3的类的__mro__属性：
			用来记录类的方法查找顺序  --->  A.__mro__
		super()函数就是根据__mro__来调用上层的方法(super(B, b).play()--->B上层类的方法)


2-00:00:00






















04： 异常高级 运算符重载