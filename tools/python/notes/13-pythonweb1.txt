

01： Flask 框架 开发环境建立 模板 

1.基本知识点
	1.静态网页和动态网页
		1.静态网页：不与服务器动态交互的网页
		2.动态网页：允许与服务器做动态交互的
		
	2.服务器：给用户提供服务的机器称为服务器
	
	3.web服务器
		作用：
			1.存储web上的信息
			2.能够接受用户的请求(request)并给出响应(response)
			3.执行服务器端程序
			4.具备一定的安全功能
			
	4.框架	
		框架是一个为了解决开放性问题而存在一种程序结构，框架本身提供了一些最基本的功能。
		
	5.python web框架
		1.Flask       轻量级
		2.Webpy		  轻量级
		3.Tornado	  异步框架
		4.Django	  重量级框架
		
	6.框架模式
		1.MTV
			Models	   	 模型层，主要负责数据库建模
			Templates	 模板层，用于处理用户的显示内容，如html
			Views 		 视图，处理与用户打交道的内容(请求和响应)
		2.MVC
			Models  	 模型层，主要负责数据库建模
			Views   	 视图，处理用户的显示内容
			Controller   控制器，用户与用户交互的部分内容(请求和响应)
	7.Flask是一个基于Python并且依赖于Jinja2模板引擎和Werkzeug WSGI服务的一个微型框架
		WSGI：Web Server Gateway Interface(web服务器服务网关接口)
		Flask是采用MTV的框架模式
	
2.安装Flask
	1.查看已安装的Flask版本
		1.安装Flask
			pip3 install flask
		2.import flask
			flask.__version__
	2.Flask - 路由(route)
		1.客户端发送请求给web服务器，web服务器再将请求发给Flask程序实例
			程序实例需要知道每个url请求所对应的运行代码是谁。所以程序中必须创建一个url请求地址，到python运行函数的一个映射，处理url和函数之间的关系的程序就是路由
		2.路由表示
			@app.route('/')
		3.带参数的路由
			路由中可以携带参数表示不同数据
			1.基本带参路由
				@app.route('/show/<name>')
				def show(name):
					return 'xxx'
			2.带多个参数的路由
				@app.route('/show/<name>/<age>')
				def show(name,age):
					return 'xxx'
			3.指定参数类型的路由
				@app.route('/show/<name>/<int:age>')
				def show(name,age)
				
				Flask中所支持的类型转换器
					类型转换器		作用
					缺省			字符串，不能有斜杆('/')
					int:			整型
					float:			浮点型
					path:			字符串,可以有斜杠
					
			4.多url的路由匹配
				@app.route('地址1')
				@app.route('地址2')
				...
				def show(name,age):
			
			5.路由中设置HTTP请求方法
				Flask路由也允许设置对应的请求方法(post/get),只有将匹配上请求方法的路径才能交给对应的视图处理函数去处理，所有的路由，默认只接受get请求
				@app.route('/',methods=['get','post'])
			6.url的反向解析
				正向解析：程序自动解析，根据@app.route()中的访问路径，来匹配处理函数
				反向解析：通过视图处理的函数的名称自动生成对应的访问路径
				在Flask中实现反向解析:
					url_for(funName,args)
						funName:要生成地址的函数名
						args:该地址中需要的函数
		

		
		
		

02： WEB 表单 数据库 


Templates模板：相应的网页
	1.
		在模板中，允许包含"占位变量"来表示动态的内容
		模板最终也会被解析成字符串再响应给客户端，这一过程通常称为"渲染"
		Flask中的模板是依赖Jinja2的模板系统
	2.模板的设置
		默认情况下，Flask会在程序文件夹中的templates(根目录下)的子文件夹中搜索模板
		默认情况下，需要手动创建templates文件夹
	3.模板的渲染
		作用：在视图中，将模板文件(xx.html)渲染成字符串之后，再响应给客户端浏览器
		函数：render_template('xx.html')
	4.模板中的语法
		1.变量
			变量是一种特殊的占位符，告诉模板引擎该位置的值是从渲染模板时的数据中获取出来的
			在视图中
			@app.route('/')
			def index():
				return render_template('xxx.html',变量1=值1,...)
			在模板中：
			{{变量名}}
			变量类型：字符串，数字，列表，元组，字典...
			引用: 
				列表：list.0/list.[0]   
				元组：tup[1]/tip.1  
				字典：dic['name']/dic.name
				person对象的name属性：
					<h1>person.name:{{params.person.name}}</h1>
				person对象的方法：
					<h1>person.say:{{params.person.say()}}</h1>
		2.过滤器
			过滤器是允许在变量输出前改变变量的值
			语法：
				{{变量|过滤器}}
			Jinja2 模板中常见的过滤器：
				过滤器名                说明
				capitalize				首字符大写，其它小写
				lower					将值转换成小写
				upper					将值转换成大写
				title					将值中的每个单词首字符变成大写
				trim					去掉值两边的空格
		3.标签
			每个标签指的是不同的服务器端的功能
			模板：
			常用标签{% %}
				1.if 标签
					{% if 条件 %}
						执行语句
					{% elif 条件 %}
						执行语句
					{% else %}
						执行语句
					{% endif %}
						执行语句
				2.for 标签
					{% for 变量 in 元组/列表/字典 %}
					{% endfor %}
					
					在Jinja2模板的循环中，支持内部变量-loop
					loop作用：记载但钱循环中的一些相关信息
					loop常用属性：
						1.index
							用法：loop.index
							作用：记录当前循环的次数，从1开始记录
						2.index0
							用法：loop.index0
							作用：记录当前循环的次数，从0开始记录
						3.first
							用法：loop.first
							作用：值为True，则表示当前循环时第一次循环
						4.last
							用法：loop.last
							作用：值为True，则表示当前循环时最后一次循环
				3.macro标签(宏)
					1.作用：相当于是在模板中声明函数
					2.语法：
						{% macro 名称(参数列表) %}
							语句
						{% endmacro%}
					3.在独立的文件中声明宏
						1.创建macro.html 模板文件
							定义项目中要用到的所有的宏
						2.导入macro.html
							{% import 'macro.html' as macros %}
				4.include标签
					将其它的模板文件包含到当前的模板文件中,在哪里导入，在哪里执行
					语法：{% include 'xxx.html' %}
	5.动态文件处理
		1.在Flask中不能与服务器动态交互的文件都是静态文件
		2.静态文件的处理(js/css/images)
			1.所有的静态文件必须放在名为static的目录中
				static目录要放在项目的根目录处
			2.所有的静态文件必须通过/static/路径访问
	





03： 项目结构 用户管理 分页 

1.静态文件地址的反向解析
	url_for('static',filename='<file_path>')   -->  浏览器访问/static/<file_path>
2.模板的继承
	一个模板中出现的内容来自于另一个模板，那么可以使用继承的方式简化开发
	语法：
		1.父模板：
			需要定义出哪些东西在子模版中是可以被重写的
			{% block 块名 %}
				父模板中正常显示的内容
			{% endblock %}
			block:
				1.在父模板中是可以正常显示的，没有任何影响
				2.在子模板中是可以被重写的
		2.子模版
			1.指定继承自那个父模板
				{% extends '父模板名称' %}
			2.重写父模板中对应的内容
				{% block 块名 %}
					子模版覆盖
					允许通过{{super}}来调用父模板中的内容
				{% endblock %}
			



1-01：42








04： 国际化与本地化、测试、项目部署 测试 项目部署





























