

01： Python工具使用 WEB与服务器、框架 MVC 与 MTV 


Django：开源框架，采用python语言编写
	自带强大的后台管理系统
官方参考文档：https://docs.djangoproject.com/zh-hans/2.2/
	中文文档：搜索：djangobook

MTV：
	M：models
	T：templates
	V：views



在线安装：pip3 install django==1.11.8
离线安装：pip3 install Django-1.11.16.tar.gz

1.Django框架的使用
		1.创建项目
			使用django-admin 创建django项目
			语法：django-admin startproject 项目名称(TestDjango)
	
	manage.py ：一种命令行工具,在项目目录下，使用python3 manage.py 可以查看
		启动：python3 manage.py runserver 0.0.0.0:8000
				(./manage.py runserver 这样启动需要修改manage.py 的python解释器版本)
			在项目目录下，与项目名称一致的目录称为主目录
	__init__.py ：初始化文件，让 Python 把该目录当成一个开发包 (即一组模块)所需的文件
	urls.py：Django项目的URL设置。 可视其为你的django网站的目录
	wsgi.py: web server gateway Interface
	settings.py ：该 Django 项目的设置或配置
		BASE_DIR:项目路径
		DEBUG: True则修改配置后会重启
		ALLOWED_HOSTS：允许访问本项目的地址列表(默认127.0.0.1),推荐写['*'],同时启动时需要指定地址和端口
		INSTALLED_APPS：指定已安装的应用，有自定义的应用的话，需要在此注册
		MIDDLEWARE：中间件，有自定义的中间件需要在此注册
		ROOT_URLCONF：路由配置文件
		TEMPLATES：配置模板的信息
		DATABASES：配置数据库的信息
		LANGUAGE_CODE：语言设置(中文："zh-Hans")
		TIME_ZONE:时区(中国时区："Asia/Shanghai")
2.url的使用
	1.urls.py
		默认是在主目录中，主路由配置文件，会包含最基本的地址映射，并且每个地址访问都必须要先经过该文件
		作用：通过urls中定义好的地址找到对应的视图处理函数
	2.url()的语法
		作用，为了匹配用户的访问路径
			from django.conf.urls import url
			url(regex,views,kwargs=None,name=None)
				1.regex:允许是正则表达式，匹配请求的url
				2.views:地址匹配后要执行操作的视图处理函数
				3.kwargs:字典，用来向views传参的，可以省略
				4.name:为url起别名，在地址反向解析时使用
	
配置应用：
	1.urls.py
	2.views.py(相同目录下创建自定义试图文件)
	通过url向视图传参
		1.使用正则表达式的子组传参，需要多个子组,中间用/隔开
		2.字典传参
			dic = {
				'name':'sasuke',
				'age':18
				}
django中的应用
	应用就是网站中的一个独立的程序模块
	在django中，主目录一般不处理具体的请求，主目录一般处理项目的初始化操作以及请求的分发(分布式请求处理)，而具体的请求是由各个应用去处理
	创建应用：
		1.指令:
			python3 manage.py startapp 应用名称
		2.在setting.py
			INSTALLED_APPS中追加应用的名称来表示注册应用
	应用的结构组成：
		1.migrations文件夹
			存放数据库的中间文件
		2.__init__.py 
			应用的初始化文件
		3.admin.py
			应用的后台管理配置文件
		4.app.py
			应用的属性配置文件
		5.models.py
			Models与模型相关的映射文件
		6.tests.py
			应用的单元测试文件
		7.views.py
			定义视图处理函数的文件
	分布式路由系统：
		在每个应用中分别创建urls.py格式和主路由文件一样
		目的：为了处理各个应用中的请求路由
	
	访问路径为：host:port/apps/path
	
	
	
	
	

02： Django介绍 Django中的应用 模板的加载方式 

Django中的模板：templates
	1.模板就是要动态呈现给用户的网页
	  模板引擎是由Django自己提供的，而非Jinja2，与Flask语法稍微不同
	2.模板设置
		在setting.py中设置TEMPLATES变量
		1.BACKEND：指定使用的模板引擎
		2.DIRS：指定模板的存放目录
			1.DIRS=[os.path.join(BASE_DIR,'templates')],
				在项目的根目录的template目录中存放所有的模板
			2.DIRS=['index.temp','music.temp']
				在项目的index应用中的temp目录中存放模板及music应用中的temp目录中存放模板
		3.APP_DIRS:是否要自动搜索应用中的templates目录
		4.OPTIONS：额外配置
	3.模板的加载方式
		1.通过loader对象获取模板，再通过HttpResponse进行响应
			1.先导入loader
				from django.template import loader
			2.通过loader加载模板
				t = loader.get_template('模板名称')
				t：从Django中得到的模板对象
			3.将加载好的模板渲染成字符串,得到html
				html = t.render()
			4.通过HttpRequest将字符串进行响应并返回
				return HttpRequest(html)
		2.使用render直接加载并相应模板
			return render(request,'模板名称')
	4.模板的语法
		1.变量
			1.作用：将后端的数据传递到模板进行渲染
			2.允许作为变量的数据类型
				字符串，整数，列表，元组，字典，函数，对象
			3.变量的语法
				变量必须封装到字典中才能传递给模板
				dic = {
					'name':'王老师',
					'age':30,}				
				1.使用loader加载模板
					t = loader.get_template('模板名称')
					html = t.render(dic)
					return HttpRequest(html)
				2.使用render加载模板
					return render(request,'模板名称',dic)
			4.在模板中使用变量
				{{变量名}}
		2.标签
			1.作用：将服务器端的功能嵌入到模板中
			2.语法：官方文档：https://docs.djangoproject.com/en/1.11/ref/templates/builtins/
				{% 标签名 %}
					...
				{% end标签名 %}
				
				常用标签：在
					if 和 for
					内置变量：
						在循环中允许使用forloop内置变量来获取循环的信息
						forloop.counter
						forloop.revcounter
		3.过滤器:https://docs.djangoproject.com/en/2.2/ref/templates/builtins/#built-in-filter-reference
			在变量输出显示之前，对变量的数据进行筛选和过滤
			语法：{{变量|过滤器:参数}}
				{{value|upper}}
				{{value|lower}}
				{{value|add:num}}
				{{value|floatformat:n}}
				{{value|truncatechars:n}}
		4.静态文件：
			1.无需与服务器进行动态交互的文件
			2.在django的静态文件的处理
				在setting.py中设置有关静态文件的信息
				1.设置静态文件的访问路径
					在浏览器中通过那个地址能够找到静态文件
					STATIC_URL = '/static/'
				2.设置静态文件的存储路径
					指定静态文件要保存在服务器那个目录处
					STATICFILES_DIRS=(os.path.join(BASE_DIR,'static'),)
				3.静态文件目录的存放位置：
					1.在项目的根目录处创建一个static目录，用于保存静态文件
					2.每个应用中也可以创建一个static目录，用于保存静态文件
						访问路径:localhost:port/static/..
			3.访问静态文件
				1.直接访问静态文件
					<img src="static/images/jiayao.jpg">
				2.使用{% static %}
					1.使用之前需要通过{% load static %} 加载static
					2.使用静态资源时
						<img src="{% static 'images/jiayao.jpg'%}">
				
			




03： 模板中的语法（变量，标签，过滤器，静态文件，继承） ORM 创建和使用模型

模板的继承
	1.语法
		1.在父模板中
			必须标识出来哪些内容在子模版中允许被修改
			标签:
				{ % bloc 块名 % }
					... ...
				{ % endblock % }
				block作用：
					1.在父模板中没有任何影响，正常显示
					2.在子模版中，允许被修改，但如果不做任何修改，则显示父模板内容
		2.在子模版中
			1.指定继承自哪些父模板
				{% extends '父模板名称' %}
			2.通过black标签，改写属于自己的内容
				{% block 块名 %}
				{% endblock %}
反向解析：通过别名访问到url
	1.在模板template上做反向解析
		1.基本解析
			{% url '别名' %}
		2.带参的解析
			{% url '别名' '参数1' '参数...' %}
	2.在视图view上做反向解析
		1.基本解析
			reverse('别名')
			url就是通过别名解析出来的地址
		2.带参数的解析
			reverse('别名',args=(参数1,参数2,...))
			
模型Models：
	1.根据数据表结构而创建出来的class
	
	2.ORM：对象关系映射
		三大特征：
			1.表到类的映射
			2.数据类型的映射
			3.关系映射
			
	3.创建和配置数据库
		1.创建数据库-webdb
			create database webdb default charset utf8 collate utf8_general_ci;
		2.Django的数据库配置
			在setting.py中配置数据库的信息
			ENGINE：指定要连接的数据库的驱动引擎
				'ENGINE': 'django.db.backends.mysql',
			NAME:指定要连接到的数据库的名称
				数据库名
		3.  USER PASSWORD  HOST PORT
			以mysql数据库示例：
				DATABASES = {
					'default': {
						'ENGINE': 'django.db.backends.mysql',
						'NAME': 'webdb',
						'USER': 'root',
						'PASSWORD': 123456,
						'HOST': 'localhost',
						'PORT': 3306,
					}
				}
			（缺少模块在setting.py同级下的__init__里面导入）
			
	4.数据库的同步操作
		1.  ./manage.py makemigrations
			作用：将每个应用下的models.py文件生成一个数据库的生成文件，并将中间文件保存到migrations的目录下
		2.  ./manage.py migrate
			作用： 将每个应用下的migrations目录中的中间文件同步到数据库中
			
	5.编写Models：https://docs.djangoproject.com/en/1.11/topics/db/models/
		class Publisher(models.Model):
			name = models.CharField(max_length=30)
			属性 = models.FILETYPE(FIELD_OPTIONS)
				FILETYPE:字段类型
					BooleanField:编程语言是True/False,数据库是1/0
					CharField：varchart
					DateField：date(年月日)
					DateTimeField：datetime(时分秒)
					DecimalField：decimal类型，小数
					FloatField：float
					IntegerField：int
					EmailField：varchart
					URLField：varchart
					ImageField : varchart 图片路径
						image=models.ImageField(upload_to='images/')
						
				FIELD_OPTIONS:字段选项/说明
					default:
					null:
					db_index:
					db_column:指定当前属性映射到表中的类名
					






04： 编写Models 数据的导入和导出及版本切换 通过模型增加、查询、修改、删除数据


	6.相关指令
		1.版本切换指令
			./manage.py migrate 应用名称 版本号
		2.通过数据库自动导出models类(容易出问题)
			./manage.py inspectdb > file_name.py
			
	7.模型中的CRUD
		1.增加数据
			1.Entry.objects.create(属性值=值, ...)
				Entry：实体类
				返回值：
					插入成功返回创建好的实体对象，插入失败返回None
			2.创建一个Entry对象，并通过save()进行保存
				obj=Entry(属性=值，...)
				或obj.属性 = 值（修改）
				obj.save()
				无返回值，保存成功后，obj会被重新赋值
			3.通过字典创建Entry对象，并通过save()进行保存
				dic = {
					'属性值1':'值1'
					...
				}
				obj = Entry(**dic)
				obj.save()
		2.查询数据：https://docs.djangoproject.com/en/1.11/ref/models/querysets/
			通过Entry.objects调用查询接口函数
				Entry.objects.all()
				Entry.objects提供了对该实体的所有的数据的查询
			所有的接口函数，都可以通过一个query属性来得到所对应的sql语句
				Entry.objects.all().query
			1.获取所有的查询结果
				方法:all()
				用法：Entry.objects.all()
				返回:QuerySet(列表，查询结果集)
			2.查询指定列
				方法：value()
				返回：字典的查询结果集QuerySet
			3.查询返回指定列
				方法：values_list()
				作用：将数据封装到元组中再封装到列表中
			4.排序
				方法：order_by()
				语法：用法：Entry.objects.order_by('列...')  #默认升序排序，在列前加-表示降序
			5.查询并只能返回一条结果
				方法:get()   			#不存在或多余一条数据会异常
			6.根据条件查询部分行
				方法：filter(条件)
				返回：QuerySet
			7.非等值条件需要使用Field Lookups(查询谓词)
				语法：Entry.objects.filter(属性__查询谓词=值)
				注意：
					1.每个查询谓词都是一个独立的功能条件
						__exact: =
						__gt:
						__gte:
						__year:
						__contains:模糊查询 "%xxx%"
						__range:  模糊查询 between  and
						...
					2.所有支持条件查询的位置处都支持查询谓词
						filter() , get() , exclude()
					查询处age小于等于30的Author的信息
						Author.objects.filter(age__lte=30)
					查询处所有包含"wang"的Author的信息
						Author.objects.filter(name__contains('wang'))
					查询处date的时间是2015年以后book信息
						以后：book.objects.filter(date__year__gte=2015)
						等于：book.objects.filter(date__year=2015）
			8.取反
				方法：exclude(条件)
				Author.objects.exclude(条件)
				
			9.聚合函数(不带分组)
				方法：aggregate(列名=聚合函数('列'),...)
					Blog.objects.aggregate(number_of_entries=Count('entry'))
				聚合函数
				avg()
				count()
				sum()
				min()
				max()
				
			10.聚合查询(带分组)
 分组：当表中的列和聚合函数并用时，需要对表中的列进行分组，因为列有多个值，聚合函数没有只返回一个值
 使用Where约束来自数据库的数据，Where是在结果返回之前起作用的，Where中不能使用聚合函数。Having是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在Having中可以使用聚合函数。
				方法：aggregate(列名=聚合函数('列'),...)
				按id分组查询平均年龄
					Author.objects.value('id').annotate(avgAhe=Avg('age')).all()
				示例：	
					Author.objects
					.filter(id_gte=3)     				#where子句
					.values('isActive')  			    #group by 子句(分组)
					.annotate(avgAge=Avg('age'))        #查询聚合函数
					.filter(avgAge_gte=30)				#having 子句
					.order_by('排序列')					#order by 子句
		3.修改数据
			1.修改单个实体
				1.查
					通过get()查询出要修改的实体
				2.改
					通过实体对象的属性赋值
				3.保存
					通过实体对象save()方法保存数据回数据库
			2.批量修改数据
				调用QuerySet的update(属性=值，...)实现批量修改
		4.删除数据
			调用实体对象/查询结果集的delete()完成删除
			1.删除单个对象
				au=Author.objects.get(id=1)
				au.delete()
			2.批量删除
				aulist = Author.objects.all()
				aulist.delete()






05： F()操作与Q()操作 用后台管理Models 一对多映射查询 

	查询年龄大于平均年龄的
	sql语句：
		select * from index_author
		where age > (select avg(age) from index_author);
	年龄都加上10
	sql语句
		update index_author set age=age+10;




1-00:52





06： 多对多映射查询 HttpRequest使用 csrf跨站点攻击 










07： 使用 forms 模块 模板中解析 form 对象 forms高级处理 










08： cookies session会话















