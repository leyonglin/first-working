

01： 高阶函数 map filter sorted eval exec

面向过程编程：普通编程
函数式编程function programing：用一系列函数解决问题
函数的可重入性，当一个函数的输入一定，则输出必然一定的函数称为可重入函数
	可重入函数内一定不会访问除局部变量以外的变量
高阶函数high order function
	包含其中一个条件的函数：1.函数接受一个或多个函数作为参数传入   2.函数返回一个函数
	内置的高阶函数：map   filter   sorted
	map函数：map(func, *iterable)
		返回一个可迭代对象，此可迭代对象用函数func对可迭代对象iterable中每一个元素作为参数后得到新的数据
	1.print(sum(map(lambda x: x**2, range(1, 10))))	
	2.def mypow(x,y):
		  return x**y
	  for i in map(mypow,[1,2,3],(4,3,2,1)):
		  print(i)
	
	filter函数：filter(function, iterable)
		作用：筛选可迭代对象iterable中的数据(对每个function返回数据进行bool求值)，返回一个iterable中符合条件的可迭代对象的数据
	
	sorted函数：将原可迭代对象的数据(可排序对象)进行排序，生成排序后的列表
		格式：sorted(iterable, key=None, reverse=False)
		key是一个用来提供作为排序的依据的值
			L=[1,-2,5,-3]
			L1=sorted(L,key=abs,reverse=True)     #按绝对值由大到小排序
			print(L1)
			
递归函数recursion：指函数直接或间接的调用自身(递归有层数限制)
	递归需要控制好层数，当符合某一条件是要终止递归调用，几乎所有的递归都能用while循环来代替
	递归调用分为两个阶段：
		1.递推阶段：从原问题出发，按递归公式递推，从未知到已知，最终达到递归终止条件
		2.回归阶段：按递归终止条件求出结果，逆向逐步代入递归公式，回归到原问题求解
	示例：# 求阶乘
		def myfac(n):
			#用递归来实现 5！ = 5 * 4！
			if n == 1:
				return 1 
			return n * myfac(n-1)
		print(myfac(5))

闭包closure：指引用了此函数外部变量的函数(是一个内嵌函数变量)
	如果一个内嵌函数访问了外部嵌套函数的变量，则这个内嵌函数就是闭包
	条件：1.必须有一个内嵌函数   2.内嵌函数必须引用外部函数中的变量   3.外部函数返回值必须是内嵌函数
	示例def make_power(y):
			def fn(x):                    #内嵌函数变量fn是闭包
				return x ** y
			return fn
		pow2 = make_power(2)              #pow2绑定fn
		print('5的平方是：', pow2(5))     #y作为fn的外部变量，由于fn形成闭包，所以y不会被销毁




02： 闭包 装饰器

装饰器decorator：装饰器是一个函数，主要作用是用来包装另一个函数或类，目的是在不改变原函数(类名)的情况下改变被包装对象的行为
函数装饰器：指装饰器是一个函数，传入的是一个函数，返回的是另一个函数
	语法：  def 装饰器函数名(参数)：
			    语句块
			    return 函数对象
			    
		    @装饰器函数名
		    def 函数名(形参列表)：
			    语句块
		    
            def mydeco(fn):            #装饰器函数，里面会内嵌一个fx函数
            	def fx(name):
            		print('1')
            		fn(name)
            		print('2')
            	return fx
            
            @mydeco          
            def  myfun(name):
            	 print('myfun')
            
            #@mydeco 相当于myfunc()被调用了后，先fn=myfun，myfun调用了fx再调用fn， 再myfun=mydeco(myfun)   
            myfun()                    #返回其他fx函数执行结果

函数的文档字符串：函数内第一次未赋值给任何变量的字符串是此函数的文档字符串
	语法：  def 函数名(参数列表)：
				'函数文档字符串'
				语句块
	说明，1.文档字符串通常用来说明函数的功能和使用说明
		  2.交互模式下，输入：help(函数名)，可以查看函数的文档字符串
		  3.函数的文档字符串绑定在函数的__doc__属性上
	以双下划线开头，以双下划线结尾的标识符通常代表python的特殊变量
	函数的__doc__属性：用来记录文档字符串
	函数的__name__属性用于记录函数名
	
	函数定义的完整语法：
		[@装饰器名1]
		[@装饰器名2]
		[...]
		def 函数名(位置形参， *元组形参名, 命名关键字形参, **字典形参):
			'文档字符串'
			语句块
	
	
	L = [1, 2, 3]
	def f(n=0, lst=[])
		lst.append(n)
		print(lst)
	f(100)
	f(200)   #输出结果是[100, 200]缺省参数[]，在def语句执行时创建此列表，并一直被f函数所绑定，是bug，尽量使用不可变类型数据
	
	
模块Module：包含有一系列数据，函数，类等组成的程序组，是一个文件，通常以.py结尾
	作用：让一些相关的数据，函数，类等有逻辑的组织在一起，是逻辑结构更加清晰，模块中的数据，函数和类等可以提供给其它模块或程序使用
	分类：1.内置模块，在解释执行器内部定义，可以直接使用(通常用c语言写的)  
		  2.标准库模块，安装python时已安装且可以直接使用(通常是.py结尾文件)
		  3.第三方模块，需要自己安装   
		  4.用户自定义模块
	
	模块的导入 import
		import语句
			语法：import 模块名1 [as 模块新名1], 模块名2 [as 模块新名2], ...
		作用：将某模块整体导入到当前模块中
		用法：模块名.属性名
			  
	from import 语句块
		语法：from 模块名 import 模块属性名1 [as 属性新名1], 模块属性名2 [as 属性新名2], ...
		作用：将某模块内的一个或多个属性导入到当前模块的作用域
		
	from import * 语句
		语法：from 模块名 import *
		作用：将某模块的所有属性导入到当前模块

	函数帮助：dir(obj)函数，返回所有属性的字符串列表
			  help(obj)函数，可以查看模块的文档字符串		
			dir([对象]) 返回一个字符串列表
			作用：1.如果没有参数调用，则返回当前作用域内所有变量的列表
			2.如果给定一个对象作为参数，则返回这个对象的所有变量的列表
				1)对于一个模块，返回这个模块的全部属性
				2)对于一个类对象，返回类对象的所有变量并递归基类对象的所有变量
				3)对于其他对象返回所有变量，类变量和基类变量
	
	math time	
	计算机元年：1970年1月1日0时   UTC：坐标通用时间  CST=UTC+8	   DST阳光节约时间
	时间元组时一个9个整型元素组成的   time.gmtime([secs])#时间元组  time.localtime([secs])#本地时间元组  time.asctime([tuple])   time.time()#当前秒数  time.mktime([tuple])#指定时间秒数
	t=time.localtime()  print("%02d:%02d:%02d" % t[3:6], end='\r')	


03： 模块 包开发

系统模块sys：运行时系统相关信息
	sys.path #模块查找路径   sys.modules #已加载模块  sys.version #解释执行器版本号
	sys.platform #当前操作系统   sys.argv #程序命令行参数  sys.exit()  sys.setrecursionlimit()#修改递归层数

用户自定义模块：模块名以.py结尾，避免模块名与内建模块冲突
	模块属性就是模块内部全局变量
	模块导入路径：1.索引内建模块builtin    2.搜索程序的运行时路径(当前路径)   3.sys.path提供的路径(也可以列表追加模块路径)

模块的加载过程：
	在模块导入时，模块的所有语句都会执行，如果一个模块已经被导入，则再次导入时不会重新执行模块内的语句	

模块重载：1.import imp    2.imp.reload(modules)   

模块被导入和执行的过程：1.先搜索相关路径找模块文件(.py文件)
	2.判断是否有此模块对应的.pyc，如果pyc文件存在，且比.py文件新(修改时间)则直接加载.pyc文件
	3.否则用模块吗.py文件生成.pyc(在__pycache__目录下)并加载执行

模块的编译：.py --编译-->.pyc --解释执行器-->python3

模块的属性：
	模块的文档字符串：模块内的第一次没有赋值给任何变量的字符串，绑定在模块的__doc__属性上
	  模块的隐藏属性：模块中以'_'开头的属性，在from modules import * 导入时将不被导入，通常称这些属性为隐藏属性
	    __all__      #模块中的__all列表必须是一个字符串列表   作用：当仅当用from  modules import * 导入的是__all__里的列表属性。而不是模块的全部变量
		__doc__      #用来绑定文档字符串
		__file__     #用来绑定此模块对应的文件路径
		__name__     #1.记录模块自身的名字    2.判断是否为主模块(主模块是指当前 被python3执行的模块程序)
					  #当此模块为主模块运行时，__name__的值为'__main__' ,当此模块不是主模块时，__name__绑定模块的名字		
		
随机模块random： R.random()#返回[0,1)之间的随机数	R.uniform(a,b) #(a,b)   R.randrange([start,]stop[,step])
				R.choice(seq)#从序列返回随机元素    R.sample(seq.n)#从序列中选择n个随机且不重复的元素  R.shuffle(seq[,random])#随机指定序列的顺序(乱序序列)

包(模块包)package：将模块以文件夹的组织形式进行分组管理的方法，可以被导入
		作用：将一系列模块进行分类管理，有利于防止命名冲突，可以在需要时加载一个或部分模块而不是全部模块
	包内的__init__.py文件：是常规包内必须存在的文件，文件会在包加载时被自动调用
		作用：编写此包的内容，编写包的文档字符串
		导入规则：1. import 包名.子包名.模块名 [as 模块新名]    1.1  import 包名.模块名 [as 模块新名]    1.2 import 包名 [as 包新名]
				  2.from 包名.子包名.模块名 import 属性名 [as 属性新名] ...      3.from 包名.子包名.模块名 import *  ...
	搜索路径：1.搜索程序运行时的路径(当前路径)    2.sys.path提供的路径
	__init__.py内的__all__列表：用来记录此包中有哪些子包或模块需要导入
		说明：__all__列表只有在from modules import *导入时起作用
	包的相对导入：指包内模块的相互导入
		语法：1.from 相对路径包或模块名  import 属性或模块名    2.from 相对路径包或模块名 import * (. .. ...上两级目录，依次类推)
		
		

04： 异常 断言

异常：exception
	异常：程序错误发生时标识的一种状态，当异常发生时，程序不会再向下执行，而转去调用此函数的地方待处理此错误并恢复为正常状态
		作用：用作信号，通知上层调用者有错误产生需要处理
	错误：由于逻辑或语法等导致一个程序无法正常执行的问题，是引起异常状态的原因
try语句的两种方法：函数内部和外部都能使用
	1.try-except语句    2.try-finally语句  
	try：
		可能出发异常的语句
	except 错误类型1 [as 变量1]：  #as可以绑定错误信息并打印出来
		异常处理语句1
	except (错误类型2,错误类型3)：
		异常处理语句2
	......
	except：                       #匹配其他所有异常类型
		异常处理语句other
	else：                         #正常无错误的时候执行
		未发生异常语句
	finally：                      #一定会执行
		最终语句
	说明：as子句是用于绑定错误对象的变量，可以省略
		  except子句最少要有一个，可以有多个
		  else，finally子句最多只能有一个，也可以省略		  
	作用：尝试捕获异常(接受异常通知)，将程序转为正常状态并继续执行
错误类型                                    说明
ZeroDivisionError                           除(或取模)零(所有数据类型)
ValueError									传入无效的参数
AssertionErrot								断言语句失败
Stoplteration								迭代器没有更多的值
IndexError									序列中没有此索引
IndentationError							缩进错误
OSErrot										输入/输出操作失败
ImportError									导入模块/对象失败
NameError									未声明/初始化对象(没有属性)
AttributeError								对象没有这个属性
GeneratorExit								生成器发生异常来通知退出
TypeError									对类型无效的操作
Keyboardinterrupt							用户中断执行(通常是输入^C)
OverflowError								数值运算超出最大限制
FloatingPointError							浮点计算错误
BaseException								所有异常的基类
	
	try-finally语句 	
		语法：
			try:
				可能触发异常的语句
			finally：
				最终语句
	说明：1.不能存在except子句  2.finally子句不可以省略	
	作用：try-finally语句不会改变程序正常/异常状态
		  通常用try-finally语句来做触发异常时必须要处理的事情，无论异常是否发生，finally语句都会被执行

try语句嵌套：指一个try语句嵌套在另一个try语句内使用	

raise语句：触发一个错误，让程序进入异常状态，发送错误通知给调用者
	语法：raise 异常类型   或   raise 异常对象   或   raise #重新触发上一次异常(在try-except语句的except子句中添加，可以传递错误)
	示例：raise ValueError("123")
		或 e = ValueError("123")  raise e

assert语句(断言语句)：当真值表达式为False时，用错误数据创建一个assertionerror类型的错误raise出去，并进入异常状态
	语法：assert 真值表达式，错误提示语(通常是字符串)
		等同于 if 真值表达式 == False:
					raise AssertionError(错误数据)

异常处理机制：在程序调用层数较多时，向主调函数传递错误信息需要层层return，返回比较麻烦，所以用异常处理机制


循环嵌套：for while
函数循环嵌套：def
递归函数：


	

05： 迭代器 生成器

迭代器Iterator：1.迭代器是访问可迭代对象的工具
				2.迭代器是指用iter(obj)函数返回的对象(实例)
				3.迭代器可以用next(it)函数获取可迭代对象的数据
	迭代器函数：1.iter(iterable)从可迭代对象中返回一个迭代器，iterable必须是能提供一个迭代器的对象
				2.next(iterator)从迭代器iterator中获取下一个记录，如果无法获取下一条记录，则触发StopIteration异常
		说明：1.迭代器只能往前取值，不能后退   2.用iter函数可以返回一个可迭代对象的迭代器
		示例：
			L=[1,3]
			it=iter(L)
			print(next(it))  #1
			print(next(it))	 #3
			print(next(it))  #StopIteration
	用途：用迭代器可以依次访问可迭代对象的数据

生成器Generator：是能够动态提供数据的对象，生成器对象也是可迭代对象(实例)
	生成器种类：1.生成器函数   2.生成器表达式
	定义：含有yield语句的函数是生成器函数，此函数被调用将返回一个生成器对象。yield翻译为产生/生成
	yield语句：
	语法：yield 表达式
	说明：yield 仅能用于def函数中，目的是将此函数作为生成器函数使用
		  yield 用来生成数据，供迭代器和next(it)函数使用
	生成器函数说明：生成器函数的调用将返回一个生成器对象，生成器对象是一个可迭代对象，通常用来动态生成数据
					生成器函数调用return语句会触发一个StopIteration错误
	示例：	  
		def myyield():  #生成器函数
			yield 2
			yield 3
			print(1)
			yield 5
			print(10)
		gen = myyield()   #调用生成器函数来创建一个生成器对象
		it = iter(gen)    #用生成器获取对应的迭代器
		print(next(it))   #访问迭代器，每次访问，从上一个yield语句之后执行直至yield语句为止
		print(next(it))   #访问迭代器
		print(next(it))   #访问迭代器,会打印出1和5，1是函数内print(1)打印出来的，5是print(next(it))
		print(next(it))   #输出10，但由于没有yield语句，会报错StopIteration
	
	
2-00：00：00







06： 文件 标准输入输出文件
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		