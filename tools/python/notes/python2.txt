

01： 高阶函数 map filter sorted eval exec

面向过程编程：普通编程
函数式编程function programing：用一系列函数解决问题
函数的可重入性，当一个函数的输入一定，则输出必然一定的函数称为可重入函数
	可重入函数内一定不会访问除局部变量以外的变量
高阶函数high order function
	包含其中一个条件的函数：1.函数接受一个或多个函数作为参数传入   2.函数返回一个函数
	内置的高阶函数：map   filter   sorted
	map函数：map(func, *iterable)
		返回一个可迭代对象，此可迭代对象用函数func对可迭代对象iterable中每一个元素作为参数后得到新的数据
	1.print(sum(map(lambda x: x**2, range(1, 10))))	
	2.def mypow(x,y):
		  return x**y
	  for i in map(mypow,[1,2,3],(4,3,2,1)):
		  print(i)
	
	filter函数：filter(function, iterable)
		作用：筛选可迭代对象iterable中的数据(对每个function返回数据进行bool求值)，返回一个iterable中符合条件的可迭代对象的数据
	
	sorted函数：将原可迭代对象的数据(可排序对象)进行排序，生成排序后的列表
		格式：sorted(iterable, key=None, reverse=False)
		key是一个用来提供作为排序的依据的值
			L=[1,-2,5,-3]
			L1=sorted(L,key=abs,reverse=True)     #按绝对值由大到小排序
			print(L1)
			
递归函数recursion：指函数直接或间接的调用自身(递归有层数限制)
	递归需要控制好层数，当符合某一条件是要终止递归调用，几乎所有的递归都能用while循环来代替
	递归调用分为两个阶段：
		1.递推阶段：从原问题出发，按递归公式递推，从未知到已知，最终达到递归终止条件
		2.回归阶段：按递归终止条件求出结果，逆向逐步代入递归公式，回归到原问题求解
	示例：# 求阶乘
		def myfac(n):
			#用递归来实现 5！ = 5 * 4！
			if n == 1:
				return 1 
			return n * myfac(n-1)
		print(myfac(5))

闭包closure：指引用了此函数外部变量的函数(是一个内嵌函数变量)
	如果一个内嵌函数访问了外部嵌套函数的变量，则这个内嵌函数就是闭包
	条件：1.必须有一个内嵌函数   2.内嵌函数必须引用外部函数中的变量   3.外部函数返回值必须是内嵌函数
	示例def make_power(y):
			def fn(x):                    #内嵌函数变量fn是闭包
				return x ** y
			return fn
		pow2 = make_power(2)              #pow2绑定fn
		print('5的平方是：', pow2(5))     #y作为fn的外部变量，由于fn形成闭包，所以y不会被销毁




02： 闭包 装饰器

装饰器decorator：装饰器是一个函数，主要作用是用来包装另一个函数或类，目的是在不改变原函数(类名)的情况下改变被包装对象的行为
函数装饰器：指装饰器是一个函数，传入的是一个函数，返回的是另一个函数
	语法：  def 装饰器函数名(参数)：
			    语句块
			    return 函数对象
			    
		    @装饰器函数名
		    def 函数名(形参列表)：
			    语句块
		    
            def mydeco(fn):            #装饰器函数，里面会内嵌一个fx函数
            	def fx(name):
            		print('1')
            		fn(name)
            		print('2')
            	return fx
            
            @mydeco          
            def  myfun(name):
            	 print('myfun')
            
            #@mydeco 相当于myfunc()被调用了后，先fn=myfun，myfun调用了fx再调用fn， 再myfun=mydeco(myfun)   
            myfun()

函数的文档字符串：函数内第一次未赋值给任何变量的字符串是此函数的文档字符串
	语法：  def 函数名(参数列表)：
				'函数文档字符串'
				语句块
	说明，1.文档字符串通常用来说明函数的功能和使用说明
		  2.交互模式下，输入：help(函数名)，可以查看函数的文档字符串
		  3.函数的文档字符串绑定在函数的__doc__属性上
	以双下划线开头，以双下划线结尾的标识符通常代表python的特殊变量
	函数的__doc__属性：用来记录文档字符串
	函数的__name__属性用于记录函数名
	
	函数定义的完整语法：
		[@装饰器名1]
		[@装饰器名2]
		[...]
		def 函数名(位置形参， *元组形参名, 命名关键字形参, **字典形参):
			'文档字符串'
			语句块
	
	
	L = [1, 2, 3]
	def f(n=0, lst=[])
		lst.append(n)
		print(lst)
	f(100)
	f(200)   #输出结果是[100, 200]缺省参数[]，在def语句执行时创建此列表，并一直被f函数所绑定，是bug，尽量使用不可变类型数据
	
	
模块Module：包含有一系列数据，函数，类等组成的程序组，是一个文件，通常以.py结尾
	作用：让一些相关的数据，函数，类等有逻辑的组织在一起，是逻辑结构更加清晰，模块中的数据，函数和类等可以提供给其它模块或程序使用
	分类：1.内置模块，在解释执行器内部定义，可以直接使用  2.标准库模块，安装python时已安装且可以直接使用
		  3.第三方模块，需要自己安装   4.用户自定义模块
	
	模块的导入 import
		import语句
			语法：import 模块名1 [as 模块新名1], 模块名2 [as 模块新名2], ...
		作用：将某模块整体导入到当前模块中
		用法：模块名.属性名
			  
	from import 语句块
		语法：from 模块名 import 模块属性名1 [as 属性新名1], 模块属性名2 [as 属性新名2], ...
		作用：将某模块内的一个或多个属性导入到当前模块的作用域
		
	from import * 语句
		语法：from 模块名 import *
		作用：将某模块的所有属性导入到当前模块

	函数帮助：dir(obj)函数，返回所有属性的字符串列表
			  help(obj)函数，可以查看模块的文档字符串		
			dir([对象]) 返回一个字符串列表
			作用：1.如果没有参数调用，则返回当前作用域内所有变量的列表
			2.如果给定一个对象作为参数，则返回这个对象的所有变量的列表
				1)对于一个模块，返回这个模块的全部属性
				2)对于一个类对象，返回类对象的所有变量并递归基类对象的所有变量
				3)对于其他对象返回所有变量，类变量和基类变量
		
闭包 装饰器2：01：44：00		
		
		
		
		
		
		
		
		
		
		
		
		
	
	
	
	
	
	
	
	

03： 模块 包开发

04： 异常 断言

05： 迭代器 生成器

06： 文件 标准输入输出文件
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		