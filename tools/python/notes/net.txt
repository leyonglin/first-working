01： 网络知识解析 套接字，tcp编程	

网络功能：数据传输

osi七层模型：网络通讯工作流程的标准化
应用层：提供用户服务，具体功能有特定的程序而定
表示层：数据的压缩优化，加密
会话层：建立应用级的连接，选择传输服务
传输层：提供不同的传输服务，流量控制
网络层：路由选择，网络互联
链路层：进行数据转换，具体消息的发送，链路连接
物理层：物理硬件，接口设定，网卡路由交换机等

优点：将工作流程标准化   降低模块之间耦合度，方便多人开发

高内聚：模块功能尽可能单一
低耦合：模块之间尽可能减少关联和影响

tcp/ip模型/五层模型：应用层  传输层  网络层 物理层  链路层 
四层：应用层  传输层  网络层 物理链路层 

数据传输流程：
	1.发送端由应用层到物理层逐层添加到信息头(首部)，最终在物理层发送
	2.中间经过节点(交换机/路由器)转发，发送到接收端
	3.在接收端根据发送端的每个信息头进行解析，最终消息到应用层展示给用户

网络协议：在网络通信中，双方都遵循的规定


域名：网络服务器地址的名称   --->  方便记忆 ，名称表达有一定含义
socket.gethostbyaddr('localhost') -->输出[主机名  别名  IP]
socket.getservbyname('mysql')
网络端口号：端口时网络地址的一部分，用于区分一个网络主机上的网络应用，不同网络应用监听不同端口号
取值：1--65535
	1-255 总所周知端口
	256-1023 系统应用端口

网络字节序：数据在网络中的传输格式

标识符（identifier）是指用来标识某个实体的一个符号，在不同的应用环境下有不同的含义。
	在计算机编程语言中，标识符是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系

传输层服务：
	面向连接的传输服务
		基于tcp协议的数据传输
			特征：提供可靠的数据传输，可靠性指数据传输过程中无丢失，无失序，无差错，无重复
		实现手段：数据传输断开前都需要进行传输和断开的确认
			三次握手：tcp传输在数据传输前建立连接的过程  
			四次握手：tcp传输在连接断开前进行断开确认的过程
	面向无连接的传输服务
		基于udp协议的传输
			特征：不保证传输的可靠性，传输过程没有连接和断开的流程，数据收发自由

应用层--根据指令向系统层请求----调用接口访问硬件

socket套接字编程：
	根据socket模块提供的接口函数，进行组合使用完成基于tcp或者udp的网络编程

套接字分类：
	流式套接字(sock_stream):传输层基于tcp协议的套接字编程方案
	数据包套接字(sock_dgram):基于udp协议的套接字编程方案
	底层套接字(sock_ram)：访问底层协议的套接字编程

	import socket
	#创建套接字
	#参数：socket_family：选择地址族类型    socket_type套接字类型(必须相同类型的套接字才能通信)    proto:选择子协议类型，通常为0     返回值：返回套接字对象
	sockfd = socket.socket(socket_family = AF_INET, socket_type = SOCK_STREAM, proto = 0)
	#绑定服务端地址
	#功能：绑定IP地址  参数：元组 (ip, port)
	#localhost 127.0.0.1  本机网卡ip   0.0.0.0
	sockfd.bind(addr)
	#设置监听套接字
	#功能：将套接字设置为监听套接字，创建监听队列   参数：n表示监听队列大小
	sockfd.listen(n)
	#等待处理客户端连接请求
	#功能：阻塞等待处理客户端连接  返回值：connfd 客户端连接套接字  addr连接的客户端地址
	#阻塞函数：程序运行过程中遇到阻塞函数则暂停运行直到某种组设条件达成再继续运行
	connfd, addr = sockfd.accept()
	#消息收发
	#功能：接收对应客户端消息   参数：一次最多接收多少字节  返回值：接收到的内容   如果没有消息则会阻塞
	connfd.recv(buffersize)
	#发送消息给对应客户端  参数：要发送的内容，必须时bytes格式   返回值：返回实际发送消息的大小
	n=connfd.send(data)
	#关闭套接字
	sockfd.close()

2-02-03






02： UDP编程，广播 HTTP协议	

套接字传输注意：
	1.监听套接字存在，客户端即可发起连接，但是最终连接的处理需要accept进行处理
	2.如果连接的另一端退出。则recv会立即返回空字串不再阻塞
	3.当连接的另一端退出时，再试图send发送就会产生brokenPipeError

网络收发缓存区：send和recv实际上时和缓冲区进行交互，发送缓冲区满时就无法发送，接收缓冲区满时recv才阻塞
	作用：协调收发处理速度，减少交互次数

tcp粘包：
	产生原因：tcp套接字以字节流方式传输，没有消息边界，发送和接收并不能保证每次发送都及时的被接收
	影响：如果每次发送内容表达一个独立的含义，此时可能需要处理粘包防止产生歧义
	处理方法：
		1.每次发送的消息添加结尾边界/标志
		2.发送数据结构体
		3.协调收发速度，每次发送后都预留接收时间

基于udp套接字的服务端：
	1.创建数据报套接字
		sockfd = socket.socket(socket_family = AF_INET, socket_type = SOCK_DGRAM）
	2.绑定地址
		sockfd.bind(addr)
	3.消息的收发：一次接收一个数据报，如果数据包大小大于buffersize，则会丢失部分消息
		data,addr=connfd.recvfrom(buffersize)
		sockfd.sendto(data,addr)
	4.关闭套接字
		sockfd.close()


sys.argv属性：获取命令行参数,得到一个列表

tcp套接字编程和udp套接字编程区别:
	1.流式套接字使用字节流的方式传输，数据报套接字以数据包形式传输数据
	2.tcp会有粘包现象，udp有消息边界不会形成粘包
	3.tcp可以保证数据传输完整性，udp则不保证
	4.tcp需要进行listen  accept操作，udp不需要
	5.tcp收发消息使用新的套接字，recv send  udp使用recvfrom，sendto

sendall(data):发送tcp消息，发送内容是bytes格式，成功返回None，失败产生异常

03： HTTP Server实现 IO类型，IO多路复用	





04： 进程理论 fork多进程编程


































