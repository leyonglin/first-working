

01： 僵尸进程 聊天室项目实践

如何避免僵尸进程产生
	1.处理子进程退出状态 os.wait()   os.waitpid
		pid,status = os.wait()
		功能：在父进程中阻塞等待处理子进程退出
		返回值：pid退出的子进程的pid号，status获取子进程退出状态
		示例：
			#处理僵尸进程os.wait()
			# import os
			# from time import sleep
			# pid = os.fork()
			# if pid < 0:
			# 	print("error")
			# elif pid == 0:
			# 	sleep(3)
			# 	print("child process pid",os.getpid())
			# 	os._exit(2)
			# else:
			# 	pid,status = os.wait()         #阻塞函数，对退出进程进行处理
			# 	print(pid,status)
			# 	print(os.WEXITSTATUS(status))  #获取子进程退出状态
			# 	while True:
			# 		pass		
		pid,status = os.waitpid(pid, option)
		功能：在父进程中阻塞等待处理子进程退出
		参数：pid  -1表示等待任意子进程退出   >0 表示等待对应PID号的子进程退出
			  option  0表示阻塞等待         WNOHANG表示非阻塞
		返回值：pid退出的子进程的pid号，status获取子进程退出状态			
		示例：
			#处理僵尸进程os.waitpid()
			import os
			from time import sleep
			pid = os.fork()
			if pid < 0:
				print("error")
			elif pid == 0:
				sleep(3)
				print("child process pid",os.getpid())
				os._exit(2)
			else:
				while True:                                 #持续监测
					sleep(1)
					pid,status = os.waitpid(-1,os.WNOHANG)  #通过非阻塞的形式捕获子进程退出      
					if status != 0:                         #判断是否还有子进程，不然后面获取子进程退出状态会报错
						break
					else:
						print(pid,status)
						print(os.WEXITSTATUS(status))  #获取子进程退出状态

	2.让父进程先退出(父进程(初始执行进程)先退出，会暂时丧失对终端的控制)
		1.父进程创建子进程等待子进程退出
		2.父进程创建二级子进程后立即退出
		3.二级子进程变成孤儿进程，和原来的父进程各自执行事件
		示例：
			#创建二级子进程
			import os
			from time import sleep
			def f1():
				sleep(3)
				print("one thing")
			def f2():
				sleep(4)
				print("second thing")
			pid = os.fork()
			if pid<0:
				print("error")
			elif pid == 0:
				#创建二级子进程,二级进程的代码从这里os.fork开始执行
				p = os.fork()          
				if p ==0:
					f2()
				else:
					os._exit(0)
			else:
				os.wait() #等一级子进程退出
				f1()



功能：类似qq群聊
1.进入聊天室需要输入姓名及密码
2.有人进入及退出聊天室会通知其他人
3.一个发送，其他人都能收到


multiprocessing 模块创建进程
	1.需要将要执行的事件封装为函数
	2.使用multiprocessing模块中process类创建进程对象
	3.通过对象属性设置和process的初始化函数对进程进行设置，绑定要执行的函数
	4.启动进程，会自动执行进程绑定的函数
	5.完成进程的回收
	#创建子进程流程：
	process()          #功能：创建进程对象   参数：name 进程名称  target(必须) 绑定参数   args 元组给target函数按照位置传参   kwargs字典给target函数按照键值对传参 
	p.start()          #功能：启动进程（target函数会自动进行，此时进程真正被创建）
	p.join([timeout])  #功能：阻塞等待回收子进程     参数 超时时间

	使用multiprocessing创建子进程，同样子进程复制父进程的全部代码段，子进程只执行传入函数(target = fun)的语句，父子进程各自执行互不影响，父子进程有各自的运行空间
	如果join没回收到子进程，子进程退出后也会变成僵尸进程
	示例：
		import multiprocessing as mp
		from time import sleep
		def fun():
			sleep(3)
			print('子进程事件')
		#创建进程对象
		p = mp.Process(target = fun)
		#启动进程
		p.start()
		#语句会继续执行
		sleep(2)
		print('这是父进程')
		#阻塞/超时回收进程
		p.join()
	使用multiprocessing创建子进程往往父进程只是用来进程回收进程的，子进程只执行传入函数(target = fun)的语句
		示例：
		import multiprocessing as mp
		from time import sleep
		import os
		def fun1():
			sleep(3)
			print('子进程事件1',os.getpid())
		def fun2():
			sleep(2)
			print('子进程事件2',os.getpid())
		#创建进程对象
		thing = [fun1,fun2]
		L = []
		for i in thing:
			p = mp.Process(target = i)
			L.append(p)
			#启动进程
			p.start()
		for j in L:
			#阻塞/超时回收进程，虽然2号进程先退出，会短暂阻塞在1号进程，但是系统在2号进程退出时会记录状态，回收完1号进程，会再回收2号进程
			j.join()               





02： multiprocessing 进程池技术，进程间通信

os.path.getsize():获取文件大小
1.如果子进程从父进程拷贝对象，对象和网络或者文件相关联，那么父子进程会使用同一套对象属性，相互有一定的关联性
2.如果在子进程中单独创建对象，则和父进程完全没有关联
multiprocessing方法：进程对象属性
p.is_alive()   #判断进程生命周期状态，处于生命周期返回True，否则返回False
p.name         #进程名称 默认为process-1
p.pid          #进程的pid号
p.daemon       #默认状态False 主进程退出不会影响子进程执行，设置为True，则子进程会随着主进程结束而结束
			   # 要在start之前设置，一般不会join一起使用

创建自定义进程类
	1.继承Process
	2.编写自己的__init__，同时加载父类init方法
	3.重写run方法，可以通过生成的对象调用start自动运行
	示例：
		#自定义进程类
		from multiprocessing import Process
		import time
		class ClockProcess(Process):
			def __init__(self,value):
				self.value = value
				super(ClockProcess,self).__init__()
			def run(self):
				for i in range(3):
					print('the time is {}'.format(time.ctime()))
					time.sleep(self.value)
		
		#创建自定义进程类的对象
		p = ClockProcess(2)
		#自动调用run
		p.start()
		p.join()
		
多进程优缺点：
	优点：1.可以使用计算机多核，进行任务的并发执行，提高执行效率    2.空间独立，数据安全    3.运行不受其他进程影响，创建方便
	缺点：进程的创建和删除消耗的系统资源较多
		
进程池技术：
	产生原因：如果有大量任务需要多进程完成，则可能需要频繁的创建删除进程，给计算机带来较多的资源消耗
	原理：创建适当的进程放入进程池，用来处理待处理事件，处理完毕后进程不销毁，仍然在进程池中等待处理其它事件，进程的复用降低了资源的消耗
	使用方法：
		1.创建进程池，在池内放入适当的进程(与核数一致)
		2.将事件加入到进程池等待队列
		3.不断取进程执行事件，直到所有事件执行完毕
		4.关闭进程池，回收进程
	from multiprocessing import Pool
		Pool(processes)                    #功能：创建进程池对象                参数：表示进程池中有多少进程processes = n
		pool.apply_async(fun,args,kwds)    #功能：将事件放入到进程池队列(异步，多进程执行速度/输出顺序不一定)        参数：func 事件函数(要先于进程池对象之前创建)    args 以元组形式给func传参   kwds 以字典形式给func传参
										   #返回值：返回一个代表进程池事件的对象   通过调用 "返回对象.get()" 可以获得事件函数的返回值
	    #pool.apply(fun,args,kwds)   	   #功能：将事件放入到进程池队列(同步)        参数：func 事件函数(要先于进程池对象之前创建)    args 以元组形式给func传参   kwds 以字典形式给func传参
		pool.close()                       #功能：关闭进程池，不能新增事件，但仍可以执行原有事件 
		pool.join()                        #功能：回收进程池
		pool.map(func,iter)                #功能：将要做的事件放到进程池   参数：func 执行函数  iter迭代对象          返回值：返回事件函数的返回值列表    r = pool.map(fun,range(10))是一个返回值列表

	示例：
		#进程池
		# from multiprocessing import Pool
		# from time import sleep,ctime
		# def worker(msg):
		# 	sleep(2)
		# 	print(msg)
		# 	return msg
		# result = []
		# #创建进程池
		# # pool = Pool(4)
		# pool = Pool(processes = 4)
		# for i in range(10):
		# 	msg = 'hello %d' % i
		# 	#将事件放入进程池队列，等待执行
		# 	# pool.apply(func = worker,args = (msg,))  #同步
		# 	# pool.apply_async(func = worker,args = (msg,))
		# 	r = pool.apply_async(func = worker,args = (msg,))
		# 	result.append(r)
		# #关闭进程池
		# pool.close()
		# #回收
		# pool.join()
		# for i in result:	
		# 	print(i.get())

进程间通信(IPC)
原因：进程空间相对独立，资源无法相互获取，此时在不同进程间通信需要专门方法

python中有地址，没有指针，使用内存不方便	
进程间通信方法：
	1.管道通信(pipe):
		通信原理： 在内存中开辟管道空间，生成管道操作对象，多个进程使用"同一个"管道对象进行操作即可实现通信(父进程创建，子进程继承)   
		from multiprocessing import Pipe
		fd1,fd2 = Pipe(duplex = True)    #功能：创建管道   参数：默认表示双向管道，如果设置为False则为单向管道    返回值：表示管道的两端，如果是双向管道，都可以读写，如果是单向管道，则fd1只读  fd2只写
		fd.recv()     #功能：从管道读取信息   返回值：读取到的内容。如果管道为空则阻塞
		fd.send(data) #功能：向管道写入内容   参数：要写入的内容  可以发送python数据类型	
	2.消息队列(Queue)：先进先出
		通信原理：在内存中建立队列数据结构模型，多个进程都可以通过队列存入内容，取出内容的顺序和存入顺序保持一致
		q = Queue(maxsize = 0)   #功能：创建消息队列    参数：表示最多存放多少消息，默认表示根据内存分配存储    返回值：队列对象
		q.put(data,[block,timeout])   #功能：向队列存储信息   参数：data要存的内容   block默认队列满时会阻塞，设置为False则非阻塞   timeout超时时间   返回值：返回取出的内容
		q.full()                 #判断队列是否为满
		q.empty()                #判断队列是否为空
		q.qsize()				 #判断队列消息数量
		q.close()                #关闭队列
	3.共享内存(Shared memory)：
		通信原理：在内存中开辟一块空间，对多个进程可见，进程可以写入输出，但是每次写入的内容会覆盖之前的内容
		obj = Value(ctype,obj)   #功能：开辟共享内存空间     参数：ctype要存储的数据类型  obj共享内存的初始化数据      返回值：共享内存对象  
		obj.value #存取单个数据类型，即为共享内存值，对其修改即修改共享内存
		obj = Array(ctype,obj)   #功能：开辟共享内存空间   参数：ctype 要存储的数据格式   obj初始化存入的内容，比如列表，字符串，如果是整数则表示开辟空间的个数    返回值：返回共享内存对象  可以通过遍历/下表获取每个元素的值   如果存入的是字符串 obj.value 表示字符串的首地址
	4.信号通信(内核发出的)：信号通信中唯一一种异步通信方法
		一个进程向另一个进程发送一个信号来传递某种讯息，接受者根据收到的信号进行相应的行为
			kill -l   查看系统信号
			sighup:终端关闭    sigint:ctrl-C终止   sigquit:ctrl-\终止    sigill/sigfpe:执行指令/算术运算错误终止  sigalrm:时钟信号
			sigkill:立即结束   sigstop:暂停       sigtstp:ctrl-z暂停    sigchld:子进程改变状态发信号给父进程   sigabort:结束进程
		os.kill(pid,sig)   #功能：发送信号   参数:pid目标进程  sig要发送的信号
		signal.alarm(sec)  #功能：终止进程   参数:sec 时间sec  进程中只能有一个时钟，第二个会覆盖第一个时间
		signal.pause()     #功能：阻塞等待接收一个信号，先让进程阻塞，直至有信号发送过来直接结束
		signal.signal(signum,handler)  #功能：处理(修改)信号    参数：signum 要处理的信号   handler 信号的处理方法(SIG_DFL表示使用默认的方法处理 SIG_IGM表示忽略这个信号 func传入一个函数表示用指定函数处理(格式：def func(sig,frame) sig:捕获到的信号 frame：信号对象))      
	5.信号量:   
	6.套接字	


                 管道         		 消息队列        		 共享内存
开辟空间         内存         		   内存          		    内存
读写方式   两端读写/双向/单向 		  先进先出       		覆盖之前内容
效率             一般         		    一般         		    较高
应用          多用于父子进程  		 广泛灵活/第三方 		 注意互斥操作
		
同步执行：按照顺序逐句执行，一步完成再做下一步
异步执行：在执行过程中利用内核记录延迟发生或者准备处理的事件。这样不影响应用层的持续执行，当事件发生时再由内核告知应用层处理



1-01:17:30



03： 进程通信 进程同步互斥




































04： threading线程 线程同步互斥 GIL
05： 并发编程 tftp文件服务器








