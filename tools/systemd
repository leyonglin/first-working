
man n systemd.unit
man systemd.service
man systemd
man systemd.exec

systemctl list-dependencies httpd [--reverse]  查看依赖
systemctl list-unit --all | grep sshd  /  systemctl --type=service
systemd-analyze blame
systemctl cat multi-user.target(httpd.service..)
systemctl status httpd           /         systemctl get-default

systemctl路径：/etc/systemd/system/* 优先于 /usr/lib/systemd/system/*
init路径：/etc/init.d/(脚本)      /etc/rc*  --> /etc/rc.d/rc*

系统初始化级别脚本运行之后自动执行的：/etc/rc.local
init.d目录下的脚本：以K开头的脚本运行在以S开头的脚本之前(开机自启:update-rc.d redis defaults)
                    service xxx启动/etc/init.d/目录下的xxx脚本(或者Redirecting to /bin/systemctl start docker.service)

systemctl get-default  && systemctl cat multi-user.target  (AllowIsolate：允许使用systemctl isolate命令切换到multi-user.target。)

systemctl status:
Loaded行：配置文件的位置，是否设为开机启动
Active行：表示正在运行
Main PID行：主进程ID
Status行：由应用本身（这里是 httpd ）提供的软件当前状态
CGroup块：应用的所有进程
日志块：应用的日志

	
systemd(systemctl):基本用法  
  systemctl start/stop/enable/disable/mask.. [service]
  查看系统上上所有的服务systemctl [command:–list-units] [–type=TYPE] [–all]
  getty.target:用来设置tty的数量  get-default:取得当前的target  isolate:切换到指定的运行级别
  分析各服务之前的依赖关系:systemctl list-dependencies [unit] [––reverse:用来检查寻哪个unit使用了这个unit]
  关闭服务:systemctl list-units --all | grep sshd  (如果只闭关了 sshd.service 那么 sshd.socket还在监听网络，在网络上有要求连接 sshd 时就会启动 sshd.service 。因此如果想完全关闭sshd服务的话，需要同时停用sshd.service和sshd.socket)
  分析systemd启动进程: systemd-analyze [blame][-h]
  
centos7之前是启动服务：service [service] 选项 自启：chkconfig [service] on/off   切换级别：init 0~6  
systemd配置文件被称为unit单元，根据类型不同，以不同的扩展名结尾。
 systemctl --type=service [systemctl list-units]
  .service系统服务；
  .target一组系统服务,引用其他 unit；
  .slice一组分层次管理的系统进程；
  .automount自动挂载点；
  .mount挂载点；
  .device能被内核识别的设备；
  .path文件系统的文件或者目录；
  .scope外部创建的进程；
  .snapshot系统服务状态管理；
  .socket进程间通讯套接字；
  .swap定义swap文件或者设备；
  .timer定义定时器。		

		
Systemd:
	主要有四种类型文件
	*.mount:定义了一个挂载点，[Mount]节点里配置了What,Where,Type三个数据项
	*.service:文件定义了一个服务，[Unit]，[Service]，[Install]三个小节
	*.target:定义了一些基础的组件，供.service文件调用
	*.wants:定义了要执行的文件集合，每次执行，.wants文件夹里面的文件都会执行

[Unit] 
Description：描述及systemctl status 输出的此服务的说明
Documentation：帮助文档位置
After：此unit是在哪个daemon启动之后才启动的意思(非强制)只涉及启动顺序,不涉及依赖关系。
Before：最好在什么服务启动前启动这个服务(非强制)只涉及启动顺序,不涉及依赖关系。
Requires：明确的定义此unit需要在哪个daemon启动后才能够启动,若前导服务没有启动,那么此unit就不会被启动！
Wants：规范的是这个unit之后最好还要启动什么服务比较好(弱依赖)
Conflicts：冲突检查,这个项目后面接的服务如果有启动,那么我们这个unit本身就不能启动！
AllowIsolate=yes   允许切换

[Service] 
Type：说明这个daemon启动的方式,会影响到ExecStart 
      simple（默认值）：ExecStart字段启动的进程为主进程,启动后常驻于内存中。
      forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程(据说这样的性能比较好)
      oneshot：类似于simple，但只执行一次，Systemd 会等它执行完,才启动其他服务,不会常驻在内存中(支持较多bash语法),可与RemainAfterExit连用
      dbus：类似于simple，但会等待 D-Bus 信号后启动（通常也要设置 BusName= 才行）
      notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务
      idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务(通常是开机到最后才执行即可的服务)
User=redis  指定启动用户
EnvironmentFile:指定启动脚本的环境配置文件！
或者Environment= 后面接多个不同的 Shell 变量来给予设置！
ExecStart：实际执行此daemon的指令或脚本程序(仅接受“指令 参数 参数...”的格式)要使用这些特殊的字符( <, >, >>, |, & )时，最好直接写入到指令脚本里面去(只能有一行)
(ExecStart=/bin/echo execstart1  ExecStart=   ExecStart=/bin/echo execstart2  有三行,但第二行ExecStart设为空值,等于取消了第一行的设置,运行结果为:execstart2)
也可以使用 ExecStartPre(之前) ExecStartPost(之后) ExecStopPost两个设置项目来在实际启动服务前，进行额外的指令行为
ExecStop/ExecReload
Restart:当设置 Restart=1 时，则当此 daemon 服务终止后，会再次的启动此服务，on-failure意外关闭，则会重启，正常停止，不会重启
   no（默认值）：退出后不会重启
   on-success：只有正常退出时（退出状态码为0），才会重启
   on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启
   on-abnormal：只有被信号终止和超时，才会重启
   on-abort：只有在收到没有捕捉到的信号终止时，才会重启
   on-watchdog：超时退出，才会重启
   always：不管是什么退出原因，总是重启
   对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal。
RestartSec:如果这个服务被关闭，然后需要重新启动时，大概要 sleep 多少时间再重新启动的意思。默认是 100ms （毫秒）
RemainAfterExit:当设置为 RemainAfterExit=1/yes 时，则当这个 daemon 所属的所有程序都终止之后，此服务会再尝试启动。这对于 Type=oneshot 的服务很有帮助！
TimeoutSec:若这个服务在启动或者是关闭时，因为某些缘故导致无法顺利“正常启动或正常结束”的情况下，则我们要等多久才进入“强制结束”的状态！
KillMode:可以是 process, control-group, none 的其中一种，如果是 process 则 daemon 终止时，只会终止主要的程序(ExecStart 接的后面那串指令)例如ssh，如果是 control-group 时， 则由此 daemon 所产生的其他 control-group 的程序，也都会被关闭。如果是 none 的话，则没有程序会被关闭喔！
所有的启动设置之前，都可以加上一个连词号（-），表示"抑制错误"，即发生错误的时候，不影响其他命令的执行。比如，EnvironmentFile=-/etc/sysconfig/sshd（注意等号后面的那个连词号），就表示即使/etc/sysconfig/sshd文件不存在，也不会抛出错误。

[Install] 
WantedBy:后面接的大部分是*.target unit,意思是,这个unit本身是附挂在哪一个target unit下面的,一般来,大多的服务性质的unit都是附挂在multi-user.target下面！
Also:当目前这个unit本身被enable时，Also后面接的unit也请enable的意思！也就是具有相依性的服务可以写在这里呢！
Alias:进行一个链接的别名的意思！


  
使用 systemctl 控制单元时，通常需要使用单元文件的全名，包括扩展名（例如 sshd.service）如果无扩展名，systemctl 默认把扩展名当作 .service。例如 netcfg 和 netcfg.service 是等价的。  
如果服务没有Install段落，一般意味着应该通过其它服务自动调用它们。如果真的需要手动安装，可以直接连接服务  ln -s /usr/lib/systemd/system/foo.service /etc/systemd/system/graphical.target.wants/
创建单位用的系统配置文件位于 /lib/systemd/system/，但 /etc/systemd/system 目录下的同名文件会优先于前者。(systemd-delta 查看哪些单元文件被覆盖、哪些被修改)
开机模块加载: /etc/modules-load.d/.conf 相当于原rc.conf中的MODULES变量,模块黑名单仍在/etc/modprobe.d/下,如blacklist.conf   /etc/locale.conf，相当于原rc.conf中的LOCALE

假设我们有一个 lighttpd 服务，我们现在想降低它的 niceness 值。我们需要做的就只是添加 Nice=-5 到 lighttpd.service 文件中。我们可以通过复制整个文件/lib/systemd/system/lighttpd.service 到 /etc/systemd/system/lighttpd.service 
或者在  /etc/systemd/system/lighttpd.service 中创建如下文件做到
           .include /lib/systemd/system/lighttpd.service
           [Service]
           Nice=-5
systemctl daemon-reload  重载目录下内容
 


  
  
  
  
  
  