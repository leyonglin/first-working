 
 
官方帮助文档：https://docs.docker.com/ 
官方仓库：https://hub.docker.com/
docker中文文档：http://www.docker.org.cn/faq/global/c95.html
github文档：https://github.com/docker
启动文档容器：docker run -ti -p 4000:4000 docs/docker.github.io:latest
 
Docker：把应用程序自动部署到容器，go语言编写。部署引擎，方便部署应用程序
		提供简单轻量的建模方式，启动快。职责的逻辑分离，一致性的环境。缩短开发生命周期。鼓励使用面向服务的架构，[启动一个进程]
		优点：Flexible(灵活) Lightweight(轻量级) Interchangeable(可交换) Portable(可移植性) Scalable(可伸缩性) Stackable(可堆叠)
容器是一种虚拟化的方案，运行在操作系统之上的，操作系统虚拟化，依赖linux内核的namespace和cgroup，资源占用少

镜像保存：/var/lib/docker 

docker基本组成：
docker client    客户端
	c/s架构    本地/远程  客户端访问守护进程
docker daemon    守护进程
docker image     镜像
	容器的源代码(构建和打包)，1.容器的基石，2.层叠的只读文件系统(引导文件系统bootfs---rootfs(centos/ubuntu...)(基础镜像)---3.联合加载(。。。))
docker container 容器
	通过镜像启动，启动和执行阶段。启动镜像会加载一个可写层(写时复制)
docker registry  仓库
	公有和私有

docker客户端通过访问docker守护进程，操作docker容器。容器通过镜像启动，镜像保存仓库

docker virsion  
docker search 
docker pull   
docker run learn/least CMD
docker ps -l
docker commit  ID  learn/ping
docker inspect ID
docker image 
docker push NAME

使用技术：[编程中：命名空间是一种封装概念，实现代码隔离]
namespaces：PID  NET  IPC MNT(文件系统相关)  UTS(隔离内核和版本标识)
control groups控制组：资源限制   优先级设定  资源计量  资源控制(挂起或恢复)
docker容器的能力:文件系统隔离(root文件系统)  进程隔离：  网络隔离   资源隔离和分组

ubuntu安装docker：
检查：
内核版本：uname -a
内核驱动：/sys/class/misc/device-mapper/(存在既有)
whereis curl
安装
sudo apt-get install -y curl
curl -sSL https://get.docker.com/ubuntu/  | sudo sh
创建docker组：sudo groupadd docker
			  sudo gpasswd -a jkxy docker
			  sudo service docker restart （root启动）
			  重新登陆系统...docker用户组可以使用docker命令(不用sudo)

window(通过虚拟机)安装：boot2docker for windows---高版本可能不需要

os x :(通过虚拟机) boot2docker组件提供运行环境与命令工具


容器基础操作：docker run NAME/TAGS CMD
docker start|stop|restart 容器名     启动/停止/重启容器
docker run -it --name=自定义名称  IMAGE CMD  [-g "daemon off;"]  --restart always开机自启
-i --interactive=true|false 默认是false(标准输入)   -t --tty=true|false  默认是false 伪终端  

docker run -d centos /bin/sh -c "while true;do echo hello docker;sleep 1;done"

docker start [-i] 容器名        重新启动停止的容器
docker rm  ID                   删除停止的容器

docker ps[container ls]  默认是正在运行的容器    -l 最新的容器  -a 包括停止的容器

docker inspect ID   详细信息
 实例：docker inspect --format="{{.Volums}}"  容器名     查看数据卷信息

守护式容器：长期非交互式运行
交互式运行容器 + ctrl+p + ctrl+q   ---保持容器运行
进入到运行中的容器：docker attach 容器名
docker run --name container01 -d  NAME  CMD  程序完成，容器会停止

查看容器内部程序结果：
docker logs [-f] [-t] [--tail] 容器名  （默认返回所有）
-f --follows=true|false 默认是false  跟踪日志变化结果
-t --timestamps=true|false 默认是false
--tail n  输出最后n条  默认输出所有all

查看运行容器进程：docker top 容器名
查看容器端口：docker port 容器名

在运行容器内启动新进程：
docker exec [-d] [-it] 容器名 [COMMAND] [ARG...]

停止守护式容器：docker stop 容器名    docker kill  容器名---强制杀死

docker帮助文件：例如 man docker-run    man docker-logs

设置容器的端口映射：
docker run [-P映射所有端口] [-p指定映射端口  宿主机端口:容器端口] 有四种 仅1.p 2.p:p 3.ip:容器p  4.ip:p:p


查看信息：docker info
查看镜像：docker images [OPTION] [REPOSITORY]
-a --all=false(列出中间层镜像)  -f --filter=[] 过滤条件  --no-trunc=true 不截断数据    -q --quiet=false 只显示镜像的唯一id

REPOSITORY 仓库，指一系列关联镜像的集合，以标签名TAGS区分的，默认使用latest镜像，可为同一个镜像(id相同)打上不同标签
REGISTRY组件仓库，集中存储与分发镜像服务，包含很多REPOSITORY仓库,可以自定义共享镜像的服务器
定义一个私有仓库
1.在镜像仓库服务器(192.168.1.10)和docker主机的配置文件上添加该配置信息，然后重启docker
cat /etc/docker/daemon.json //不写这个文件会报错
{
"insecure-registries" : ["192.168.1.10:5000"] //使用私有仓库运行容器
}   
2.镜像仓库服务器：
docker run -d -p 5000:5000 registry 
docker tag jenkins:latest 192.168.126.131:5000/jenkins:latest
docker push 192.168.126.131:5000/jenkins:latest
3.docker主机：
curl 192.168.126.131:5000/v2/_catalog
docker run -it 192.168.1.10:5000/myos:http /bin/bash

查找镜像:在官网上找或者docker search [OPTIONS] TERM
--authmated=false  Only show automated builds  --no-trunc=false Don't truncate output  -s --stars=0 Only displays with at least x stars
拉取镜像:docker pull [OPTIONS] NAME:TAGS   -a --all-tags=false 
拉起国内镜像
在配置文件里添加：DOCKER_OPTS="--registry-mirror=URL"    (在daoclound.io网站注册账号并使用加速器生成镜像链接)
docker ps
上传镜像：docker push 

查看镜像：docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]    -f --format=""
删除镜像docker rmi     [OPTIONS] IMAGE  [IMAGE...] -f --force=false Force removal of the image    --no-prune=false Do not delete untagged parents

构建镜像：
1.docker commit 通过容器构建
	docker commit [OPTIONS] CONTAINER/[REPOSITORY[:TAGS]]  NEW_con_NAME
	-a --author=""   Author
	-m --message=""  Commit message
	-p --pause=true  pause container during commit
	
2.docker build  通过dockerfile文件构建
docker build [OPTIONS] PATH | URL | -
--force-rm=false   --no-cache=false  --pull=false  -q,--quiet=false   --rm=true   -t,--tags="REPOSITORY"
实例：docker build -t="REPOSITORY:TAGS" .

dockerfile文件的命令：顺序执行
#escape                                   escape指令设置用于在Dockerfile中转义字符的字符。如果未指定，则缺省转义字符为\
#添加注释信息
FROM  REPOSITORY:TAGS                     第一条非注释指令
ARG[=<value>]							  也可以命令行传参build-args <arg>=<value>  或者 ${user:-some_user} 设置默认值  但遇到ENV后会被覆盖
										  预定义变量HTTP_PROXY  http_proxy  HTTPS_PROXY  https_proxy  FTP_PROXY  ftp_proxy  NO_PROXY  no_proxy
MAINTAINER  Author or message             维护人
RUN  CMD                                    构建时执行的命令
	两种模式：1.shell模式：/bin/sh -c CMD     2.exec模式：(可以指定其它的shell模式)["executable" , "param" , "param..."]*.md 或者 !README.md
EXPOSE  port                               开放的端口(容器运行时，仍需要在run命令中指定)
[HEALTHCHECK]CMD ["","",""...]             [健康检查--interval= --timeout= --start-period= --retries=]
										   与RUN相似，但是是在容器启动是执行的，如果容器启动是指定命令，则会被覆盖。一般搭配ENTERYPOINT，为其提供默认参数
SHELL ["executable", "parameters"]
ENTERYPOINT                                与CMD区别是不会被覆盖，除非添加参数docker run --entrypoint,因此可以是ENTERYPOINT指定命令，CMD指定参数
ADD <src> <dest>  ["<src>"..."<dest>"]     src是本地相对路径，dest是本地绝对路径，对于远程url，建议使用wget或者curl获取文件,包含类似tar的解压功能
COPY <src> <dest> ["<src>"..."<dest>"]     src是本地相对路径，dest是本地绝对路径，对于远程url，建议使用wget或者curl获取文件，适合单纯复制文件
VOLUME ["/data"]                           卷，存在一个或多个容器，绕过联合文件系统，提供数据共享或数据持久化功能
WORKDIR                                    工作目录，指定命令都在改目录下运行，使用绝对路径
ENV <key><value>   <key>=<value>           设置环境变量，构建和运行中都有效                            
USER                                       以什么用户执行  user/user:group/user:gid/uid...
ONBUILD                                    触发器，当镜像被其它镜像当作基础镜像执行时，或出发[dockerfile--image--image(触发)]
LABEL <key>=<value> <key>=<value> <key>=<value> ...

docker的c/s模式
1.user --- docker client(命令行接口--docker二进制程序--输入docker命令) --传递--> docker daemon(负责实现功能) 处理  --返回客户端
2.通过remoteAPI可以自己编写程序调用接口进行集成(也可交互，即输入输出)   docker文档：https://docs.docker.com

客户端和守护进程通过socker进行连接
1.unix:///var/run/docker.sock(默认)     nc -U /var/run/docker.sock --> GET /info HTTP/1.1(查看remoteAPI的接口信息) 
2.tcp://host:port
3.fd://socketfd


守护进程的配置和操作
启动docker，并查询进程--进程显示docker -d [OPTIONS] 信息
与守护进程运行相关:目录，日志级别，进程id，写入文件地址，驱动模式，debug模式调试
-D --debug=false   -e，--exec-driver="native"   -g，--graph="/var/lib/docker"   -d，--detach=true
--icc=true   -l，--log-level="info"
--label=[]   -p，--pidfile="/var/run/docker.pid"  -------例子[--label name="container01"]
与服务器连接相关：用户组，安全相关tls  连接socket配置(-H)
-G，--group="docker"    -H,--host=[]  --tls=false   --tlsverify=false
--tlsacert="/home/sven/.docker/ca.pem"   --tlscert="/home/sven/.docker/cert.pem"   --tlskey="/home/sven/.docker/key.pem"
RemotAPI相关：--api-enable-cors=false
存储/驱动/设置相关：-s,--storage-driver=   --selinux-enabled=false    --storage-opt=[]
Registry连接相关：--insecure-registry=[]     --registry-mirror=[]
网络设置相关： -b,--bridge=""   --bip=""   --fixed-cidr=""    --fixed-cidr-v6=""   --dns=[]   --dns-search=[]
			   --ip=0.0.0.0  ip-forward=true  --ip-masq=true  --iptables=true  --ipv6=false  --mtu=0
		帮助文档：https://docs.docker.com/reference/commandline/cli
在配置文件中添加：DOCKER_OPTS=""
docker info   可以查看到修改


docker远程访问：
docker服务器：客户端可以curl http://ip:port/info
在服务器端配置文件配置   -H  1.tcp://host:port(2375)     2.unix:///path/to/socket(默认)    3.fd://* or fd://socketfd 
          配置文件实例：DOCKER_OPTS="--label name=container01 -H tcp://host:port -H unix:///var/run/docker.sock"
				
在客户端命令行：-H  1.tcp://host:port(2375)     2.unix:///path/to/socket(默认)    3.fd://* or fd://socketfd 
    命令行实例 docker -H tcp://ip:port info  				
 设置环境变量DOCKER_HOST    export DOCKER_HOST="tcp://ip:port"   (设置变量可以不用-H指定路径)


dockerfile构建过程：从基础镜像运行容器--执行命令，修改同期--提交新的镜像层--再运行新的容器--...(构建过程会删除中间层容器，但不会删除中间层镜像)
中间层镜像可以用来调试，排查错误。
构建缓存：重复构建，会使用构建缓存(使用中间层镜像)
不使用缓存(update)：1.构建时使用选项--no-cache   2.dockerfile文件中添加环境变量ENV REFRESH_DATE 2012-08-30  时间不同会刷新之后的构建缓存
查看构建过程：docker history [image]


docker容器的网络基础(pipework:容器间网络设置)
互联理论基础
docker的守护进程时通过docker0为容器提供网络连接的，docker0是linux的虚拟网桥
网桥：根据osi七层模型，网桥是数据链路层的一个设备，通过网络设备的物理地址进行划分网络，在不同网络之间传递数据
linux的虚拟网桥：可以设置ip，是通用网路设备的一种，只要是网络设备，就能设置IP地址，则能通过路由表，在网络层定位地址，相当于拥有隐藏的虚拟网卡，网卡名字=虚拟网桥=docker0
docker守护进程(host)有虚拟网桥docker0并且打开veth*的接口 与 容器eth0的通信
网桥管理工具：bridge-utils 
              brctl show  查看网桥
              brctl addbr  br0 添加虚拟网桥(并在docker配置文件中添加-b=br0)
              ifconfig docker0 ip netmask 掩码     临时修改ip

同一宿主机容器的互联
--icc=true  选项默认同一宿主机内的容器是互联的，但是重启容器，默认情况下是会变的(如果配置文件--icc=false,则会拒绝容器间的连接)
docker run -it --name=自定义名称  --link=[CONTAINER_NAMR已存在容器名]:[ALIAS别名]  [IMAGE] [COMMOND]          新启动容器，能通过别名连接到已存在容器[名]上，重启也可以用别名连接(会改变新生成容器的ENV和hosts本地解析)
允许特定容器间的互联,需要3个选项：
1.--icc=false(阻断互联)     2.--link(特定互联)      3.--iptables=true(允许docker将规则添加到linux的iptables设置中)
iptables [-t filter] -L -n    (默认查filter表)查看规则(从上往下匹配，匹配即停止)
iptables -F                   清空规则

容器与外部网络的互联：1.ip_forward=true(docker守护进程默认为true)   2.iptables
iptables是与linux内核集成的包过滤防火墙系统
表(table)： nat  mangle  raw  filter                           iptables将同样的操作抽象为表
链(chain):  prerouting   input  output  postrouting   forward  数据处理中的不同环节或阶段
规则(rule): ACCEPT  REJECT  DROP 链下的操作
docker run -it -p 80:80 --name cct1 centos       C+p C+q
docker port cct1
iptables -I DOCKER -s ip -d ip -p tcp --dport 80 -j DROP


docker容器的数据管理：dockerfile---VOLUME ["/data"]---会自动创建数据卷，无法共享
docker容器的数据卷：volume是经过特殊设计的目录，由docker统一管理，独立于容器的存在，存在于宿主机中的文件系统(目录/文件)，可以绕过联合文件系统(UFS),可共享为一个或多个容器提供访问
					将应用与运行环境打包，环境生存周期与应用程序相一致，数据需要是持久化的，数据卷在容器删除的时候不会被删除，并且能共享的      
		docker run -it --name 容器名 -v  宿主机目录:容器目录:访问权限(ro/w)  容器名 CMD  --- 可以挂载已有目录
		docker ps -l  
		docker inspect ID
		
docker的数据卷容器
		挂载数据卷的容器，且被其它容器通过挂载这个容器实现数据共享，叫做数据卷容器
		docker run --volumes-from [CONTAINER NAME]
		docker run -it --name new_cname --volumes-from old_dcname  image  CMD   创建挂载数据卷容器的容器
		docker rm 容器名             数据卷容器被删除，挂载了数据卷容器的容器也可以访问数据，即数据卷容器只传递了数据卷篇配置的信息
		docker rm -v 容器名          删除容器及数据卷，但是不能删除仍被使用的数据卷(被挂载)
		
docker数据卷的备份和还原
		docker run --volumes-from back_cname -v 宿主机目录:容器目录 --name new_bcname  ubuntu  tar cvf 容器目录/backup.tar  容器备份目录
		执行备份命令的容器，即挂载了数据存放目录，且挂载了备份数据存放目录


docker容器的跨主机连接
    使用网桥实现跨主机容器连接(MAC OS X + Parallels软件，有的虚拟机软件不能实现)
	  同一宿主机通过docker0网桥通信，不同宿主机则是把docker0网桥桥接到宿主机网卡上，docker容器与网桥docker0与物理网卡设置为同一个网段
    ubuntu网卡配置文件设置：/etc/network/interfaces
      auth br0                    网桥名称         
      iface br0 inet static       ip分配方式(静态)
      address  ip                 ip
      netmask 
      gateway
      bridge_ports eth0            将本地网卡连接到网桥上
    docker配置文件设置：
	  DOCKER_OPTS="-b=br0 --fixed-cidr=ip/mask"       -b=br0使用自定义网桥  --fixed-cidr=ip/mask限制ip地址分配范围
		
	使用ovs(open vswitch)实现跨主机容器连接(MAC OS X + Virtualbox软件 ，双网卡host-only&NAT )
	  Open vSwitch是一个高质量，多层虚拟交换机，使用开源Apache2.0许可协议，主要实现代码为可移植的C代码，目的是让大规模网络自动化可以通过编程拓展，同时仍然支持标准的管理接口和协议(例：NetFlow,sFlow,SPAN,RSPAN,CLI,LACP,802.lag..)
     	GRE(通用路由协议封装)隧道:隧道技术(Tunneling)是一种通过互联网络的基础设施载网络之间传递数据的方式，使用隧道传递的数据或负载可以是不同协议的数据帧或包，隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送，新的帧头提供路由信息，以便通过互联网传递被封装的负载数据，是一种点对点的再封装技术
	  软件包：openvswitch-switch && bridge-utils
	 建立ovs网桥
	  ovs-vsctl show
	  ovs-vsctl add-br obr0                                               添加网桥	 
	 添加gre连接
	  ovs-vsctl add-port obr0 gre0                                        添加接口
	  ovs-vsctl set interface gre0 type=gre options:remote_ip=ip          设置接口
	 配置docker容器虚拟网桥
	  brctl addbr br0
	  ifconfig br0 ip netmask mask                                        设置ip
	 为虚拟网桥添加ovs接口
	  brctl addif br0 obr0                                                为br0网桥添加ovs网桥的连接
	  brctl show	 	 
	 添加不同Docker容器网段路由(不同网段需要查询路由表)
	  DOCKER_OPTS="-b=br0"--重启docker--再运行容器
	  route
	  ip route add  网段  via 拥有这个网段主机  dev eth0     添加路由信息，该网段需要去另一台主机找，通过eth0(下一跳和本机eth0需要同一个网端上)

	使用weave实现跨主机容器连接(MAC OS X + Virtualbox软件 ，双网卡host-only&NAT )
	  weave(编织)：建立一个虚拟网络，用于将运行在不同主机的docker容器连接起来。网址：1.http://weave.works   2.https://github.com/weaveworks/weave#readme
	 安装weave:
	   host1:wget -O /usr/bin/weave https://raw.githubusercontent.com/zettio/weave/master/weave
	         chmod a+x /usr/bin/weave                                                            启动weave
			 weave launch
			 weave run ip/mask(本容器) -it --name new_cname ubuntu /bin/bash
	   host2:wget -O /usr/bin/weave https://raw.githubusercontent.com/zettio/weave/master/weave
	         chmod a+x /usr/bin/weave
			 weave launch 另一台主机ip                                                           通过weave连接不同主机
			 weave run ip/mask(本容器) -it --name new_cname ubuntu /bin/bash                     通过weave指定IP地址启动容器，网络设备ethwe
			 
			 

docker镜像的导出：docker save -o  名称.tar  存在的镜像名     --- 类似压缩
docker镜像的导入：docker load -i  名称.tar	           
	 
扩容帮助文档：https://github.com/moby/moby/tree/master/daemon/graphdriver/devmapper
1.在存储配置文件/etc/sysconfig/docker-storage中添加：DOCKER_STORAGE_OPTIONS="--storage-opt dm.basesize=20G"
2.容器查看磁盘空间大小：df -h
  查看mapper设备信息:/dev/mapper/* 与 进入容器df -h是一致的(以下的*表示的是同样的字符串)
  查看卷信息表		：dmsetup  table  *(是/dev/mapper/*d的这个*)
  第二个数字是设备的大小，表示有多少个512bytes的扇区。(nG*1024*1024*1024/512)
  修改卷信息表：echo  $(dmsetup  table  *) | dmsetup load *           设备大小可根据自己需要修改
  激活：dmsetup resume *
  查看: dmsetup table  *
  修改文件系统：xfs_growfs  /dev/mapper/*


docker监控：
1.命令行监控：Docker Stats container
2.图形监控：下载并运行google/cadvisor:latest容器，开源免费
   docker run                                      \
   --volume=/:/rootfs:ro                         \
   --volume=/var/run:/var/run:rw                 \
   --volume=/sys:/sys:ro                         \
   --volume=/var/lib/docker/:/var/lib/docker:ro  \
   --publish=8080:8080                           \
   --detach=true                                 \
   --name=cadvisor                               \
   google/cadvisor:latest
3.Scout：被托管的服务，一个应用监控服务。在scoutapp.com注册一个Scout帐户，免费的试用账号用来集成测试。获取account_key并创建scoutd.yml,使用docker-scout指定改文件启动
4.Data Dog：被托管的服务，监控同时支持一种称为Monitors的警报功能。
5.Sensu Monitoring Framework：使用插件系统才能监控docker，运行hiroakis/docker-sensu-server容器
创建一个名为check-docker.json的文件并添加以下内容到此文件。这个文件告诉Sensu服务器在所有有docker标签的客户端上每十秒运行一个名为load-docker-metrics.sh的脚本。
cat  check-docker.json
{
"checks": {
"load_docker_metrics": {
  "type": "metric",
  "command": "load-docker-metrics.sh",
  "subscribers": [
    "docker"
  ],
  "interval": 10
}
}
}
运行容器：
docker run -d --name sensu-server                                           \
-p 3000:3000                                                            \
-p 4567:4567                                                            \
-p 5671:5671                                                            \
-p 15672:15672                                                          \
-v $PWD/check-docker.json:/etc/sensu/conf.d/check-docker.json           \
hiroakis/docker-sensu-server
脚本：定义了Docker载入指标检查
cat  load-docker-metrics.sh
#!/bin/bash
set -e

# Count all running containers
running_containers=$(echo -e "GET /containers/json HTTP/1.0\r\n" | nc -U /var/run/docker.sock \
| tail -n +5                                                           \
| python -m json.tool                                                  \
| grep \"Id\"                                                          \
| wc -l)
echo "docker.HOST_NAME.running_containers ${running_containers}"
if [ ${running_containers} -lt 3 ]; then
exit 1;
fi
使用usman/sensu-client容器来启动sensu客户端
docker run -d --name sensu-client --privileged                                \
-v $PWD/load-docker-metrics.sh:/etc/sensu/plugins/load-docker-metrics.sh  \
-v /var/run/docker.sock:/var/run/docker.sock                              \
usman/sensu-client SENSU_SERVER_IP RABIT_MQ_USER RABIT_MQ_PASSWORD CLIENT_NAME CLIENT_IP

6. cadvisor(收集)+influxdb(存储)+grafana（web展示）     参考网址：https://blog.csdn.net/qq_22211217/article/details/80867801
框架名称	特点、作用	                                                                                                                                                                       角色                                                             
cadvisor	Google开源的用于监控基础设施应用的工具，可以零配置运行在docker主机上来监控Docker主机以及Docker容器。其为但节点监控，只能监控一个主机。多节点监控可参考Google的Kubernetes。	       作为docker服务的监控数据收集器，提供给influxdb
influxdb	InfluxDB 是用Go语言编写的一个开源分布式时序、事件和指标数据库，无需外部依赖、提供管理界面。提供基于时间序列，基于事件的可度量的实时计算功能。	                                   作为数据存储器以及分析函数支持，与elk中elasticsearch作用类似，但此数据库偏向存储实时数据。
grafana	    Grafana可视化大型测量数据的开源程序，有灵活丰富的图形化选项，可以混合多种风格，多个数据源例如Graphite、zabbix、InfluxDB、Prometheus、mysql和OpenTSDB 详见配置页面。	               作为数据分析的可视化展示，与influxdb配合实现监控目的。与elk中kibana类似，但此可视化偏向实时监控数据展示
时间序列数据库，最简单的定义就是数据格式里包含Timestamp字段的数据，比如某一时间环境的温度，CPU的使用率等。
部署：
     docker network create docker-monitor  #为docker主机创建一个网卡名为docker-monitor
     docker network inspect docker-monitor #查看网卡信息
Influxdb(容器):
     docker search tutum/influxdb  && docker pull tutum/influxdb
     docker run -d --name influxdb --net docker-monitor -p 8083:8083 -p 8086:8086 tutum/influxdb     # --net：加入到网络docker-monitor上，8083为infuxdb后台控制端口，8086是infuxdb的数据端口
       访问：ip:8083        
         CREATE USER "root" WITH PASSWORD 'root' WITH ALL PRIVILEGES ##创建管理员角色 root 密码 root 供使用
         CREATE DATABASE "cadvisor"                                  ##创建数据库 cadvisor 用于接收cadvisor的监控数据
Cadvisor(容器):
     docker run --privileged=true --net docker-monitor --volume=/:/rootfs:ro --volume=/var/run:/var/run:rw --volume=/sys:/sys:ro --volume=/var/lib/docker:/var/lib/docker:ro --volume=/sys/fs/cgroup:/sys/fs/cgroup:ro -p 8087:8080 --detach=true --name=cadvisor google/cadvisor -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxdb:8086
       --privileged=true 设置挂载目录权限为最大,否则挂载出错  -storage_driver=influxdb 绑定存储驱动为influxdb   -storage_driver_db=cadvisor对应数据库名为cadvisor    -storage_driver_host=influxdb:8086 绑定数据库管理地址，容器名:容器端口
         访问：ip:8087
Grafana(容器)：
     docker run -d --name grafana --net docker-monitor -p 3000:3000   grafana/grafana
       访问：ip:3000



网络：容器默认通讯是使用网桥，也可以使用转发 1.sysctl net.ipv4.conf.all.forwarding=1   2.iptables -P FORWARD ACCEPT   (物理机上)
bridge:Bridge networks are usually used when your applications run in standalone containers that need to communicate(daemon.json，详查链接跳转)
   docker network create[rm] my-net                           创建/删除网桥
   docker network [dis]connect my-net  nginx                  使用新网桥连接已运行容器
host:直接使用主机的网络(仅linux)

overlay：distributed network(different Docker hosts/using swarm services.)
 docker network create -d overlay --attachable my_overlay     既可以使用于swarm集群服务，也可以使用单独容器间通讯的网路(--attachable)
macvlan：Macvlan networks allow you to assign a MAC address to a container(migrating from a VM setup/look like physical hosts)
 docker network create -d macvlan --subnet=192.168.32.0/24 --ip-range=192.168.32.128/25 --gateway=192.168.32.254  --aux-address="my-router=192.168.32.129" -o parent=eth0 macnet32
none: For this container, disable all networking

数据卷：/var/lib/docker/volumes/
实名(命名)卷：
匿名卷：名字由docker随机命名，添加了-rm参数，则匿名卷会随着容器的删除而删除

1.volume和bind mounts允许您在主机和容器之间共享文件，以便即使在容器停止后也可以保留数据	2.tmpfs挂载是临时的，并且仅保留在主机内存中，无法共享
创建数据卷：docker volume create my-vol
数据卷列表：docker volume ls
查看数据卷具体信息：docker volume inspect my-vol
删除数据卷：docker volume rm my-vol
根据名字移除卷:docker volume rm awesome
清除无挂载的数据卷：docker volume prune

#用于为单一容器创建数据卷
docker run -v myvol2:/app[:ro].....
#用于为集群服务创建数据卷
docker run -mount source=myvol2,target=/app[,readonly].....    (推荐,且不用实现创建数据卷)

如果容器中用于映射的文件或目录不为空，则其中的数据或是文件会拷贝到数据卷中

Docker-compose:是 Docker 容器进行编排的工具，定义和运行多容器的应用，可以一条命令启动多个容器。
Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container）
Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例
使用Compose 基本上分为三步：
   1.Dockerfile 定义应用的运行环境
   2.docker-compose.yml 定义组成应用的各服务
   3.docker-compose up 启动整个应用

在同一目录下，创建 docker-compose.yml
       cat docker-compose.yml 
         version: '2'
         services:
           web:
            build: ./dir                        1.dockerfile文件的相对路径，默认命名名称是当前目录名称_服务名
			[context: ./dir                     2.构建当前dir目录下的Dockerfile-alternate文件
            dockerfile: Dockerfile-alternate]
			image: webapp:tag                   自定义镜像名称与标签, deploying a stack in swarm mode该选项会被忽略
			args:
			  buildno: 1                        变量(可以在FROM之前声明)
            cache_from:                         使用缓存构建
			  alpine:latest 		  
			labels:                             添加构建的标签信息，键值对形式，使用双引号，使用反斜杠可以被当做一个命令行解析，每个LABEL指令都能产生一个新的层
              com.example.description: "Accounting webapp"  
			shm_size: '2gb'                      指定/dev/shm大小
            ports:
             - "5000:5000"
            volumes:
             - .:/code
            depends_on:
             - redis
           redis:
             image: redis

 
启动应用：docker-compose up [-d]          构建且启动

停止应用：docker-compose stop
查看信息：docker-compose ps
执行命令：docker-compose run services cmd   例：查看环境变量，docker-compose run web env
打印绑定的公共端口:docker-compose port eureka 8761
##构建或者重新构建服务:docker-compose build
scale：设置指定服务运行容器的个数，以 service=num 形式指定：docker-compose scale user=3 movie=3
配置dns服务器：dns:   dns: 8.8.8.8
    - 8.8.8.8
    - 9.9.9.9
dns，配置dns搜索域：dns_search ：dns_search: example.com 
dns_search:
    - dc1.example.com
    - dc2.example.com
environment：环境变量配置
env_file：从文件中获取环境变量
expose：暴露端口
image：指定服务所使用的镜像
  network_mode：设置网络模式
  network_mode: "bridge"
  network_mode: "host"
  network_mode: "none"
  network_mode: "service:[service name]"
  network_mode: "container:[container name/id]"
ports：对外暴露的端口定义，和 expose 对应
  ports:   # 暴露端口信息  - "宿主机端口:容器暴露端口"
    - "8763:8763"
links：将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况
  links:    # 指定服务名称:别名 
    - docker-compose-eureka-server:compose-eureka
  links:
    - "db:database"
volumes：卷挂载路径
logs：日志输出信息
  --no-color          单色输出，不显示其他颜.
  -f, --follow        跟踪日志输出，就是可以实时查看日志
  -t, --timestamps    显示时间戳
  --tail              从日志的结尾显示，--tail=200


docker swarm集群：
docker service create --name hello --replicas 3 --detach=false --publish 8080:80 nginx


原始镜像:体积大，可以调试
Alpine：体积最小，基于muslc的——C语言的一个替代标准库(多数Linux发行版如Ubuntu、Debian和CentOS都是基于glibc的)可能会时不时地遇到一些兼容性问题
distroless：只在容器中安装一个二进制文件可以降低总体风险。





容器本质上是受到资源限制，彼此间相互隔离的若干个linux进程的集合
OCI：多家公司共同成立的项目，并由linux基金会进行管理
dockerd:docker的守护进程,dockerd 由libcontainerd负责和containerd模块进行交换， dockerd 和 containerd 通信socket文件：docker-containerd.sock
containerd:在dockerd 启动时被启动,启动grpc请求监听,容器运行时相关的程序从docker daemon剥离出来。Containerd向dockerd提供运行容器的API，二者通过grpc进行交互。containerd最后会通过runc来实际运行容器。
docker-shim:直接通过指定的三个参数：容器id，boundle目录（containerd的对应某个容器生成的目录，一般位于：/var/run/docker/libcontainerd/containerID）,运行是二进制（默认为runc）来调用runc的api创建一个容器,（比如创建容器：最后拼装的命令如下：runc create 。。。。。）,containerd包含了container-shim代码。同一份代码，通过Makefile编译控制，编译成两个二级制文件。
container runtime，主要负责的是容器的生命周期的管理，对于容器的状态描述，以及对于容器的创建、删除、查看等操作进行了定义
runc 是对于OCI标准的一个参考实现，是一个可以用于创建和运行容器的CLI(command-line interface)工具。runc直接与容器所依赖的cgroup/linux kernel等进行交互，负责为容器配置cgroup/namespace等启动容器所需的环境，创建启动容器的相关进程
RunC 是一个轻量级的工具，它是用来运行容器的，只用来做这一件事，并且这一件事要做好。我们可以认为它就是个命令行小工具，可以不用通过 docker 引擎，直接运行容器
cri与kubernetes的概念更加贴合，并紧密绑定。cri不仅定义了容器的生命周期的管理，还引入了k8s中pod的概念，并定义了管理pod的生命周期。在kubernetes中，pod是由一组进行了资源限制的，在隔离环境中的容器组成
docker-cli(客户端)---dockerd --(grpc)-- containerd -- containerd-shim --- runc --container




Docker Cloud是一个公共仓库,是docker默认的仓库,拉取，推送镜像到设定仓库。
Docker store允许用户购买和出售自己的镜像，也可以免费发布自己的镜像。
Docker objects(组件):在使用docker的时候，将会涉及到创建、使用镜像、容器、网络、卷、插件或者其他的对象。
Docker镜像是一个只读模板，容器是镜像的可运行实例


Docker Swarm:Swarm非常容易入门,分布式系统通常是非常复杂的。与其他容器集群系统(Mesos, Kubernetes)相比，Swarm的学习曲线最低
docker service ls                                                                            查看所有服务    
docker service create --image nginx --replicas 2 nginx                                       创建服务
docker service inspect nginx                                                                 查看服务的详细信息  
docker service ps nginx                                                                      查看服务的容器状态
docker service update --image nginx:alpine nginx                                             更新服务
docker service scale nginx=5 redis=1..                                                       增加服务实例 
docker service scale nginx=0                                                                 减少服务实例（这比直接删除服务要好）
docker service rm nginx                                                                      删除服务 
docker service update --env-add VAR=NEW_VALUE --env-rm VAR                                   增加、删除环境变量
docker service update --update-parallelism 10 nginx                                          将同时更新的容器数设为10
docker service update --limit-cpu 0.25 \     --reserve-cpu 0.1 webapp                        限制webapp服务占用的CPU资源，配额0.1核，浮动上限0.25核
有状态服务（数据库、缓存、队列等）不适合部署在Swarm集群内
无状态服务（代理、网页服务器、应用服务器等中间件、监控）非常适合部署在Swarm集群内
日志管理：[docker service update --log-driver gelf --log-opt gelf-address=udp://monitoring.example.com:12201 --log-opt tag=example-tag example-service]
  对服务器程序来说，究竟是有状态服务，还是无状态服务，其判断依旧是指两个来自相同发起者的请求在服务器端是否具备上下文关系。如果是状态化请求，那么服务器端一般都要保存请求的相关信息，每个请求可以默认地使用以前的请求信息。而对于无状态请求，服务器端所能够处理的过程必须全部来自于请求所携带的信息，以及其他服务器端自身所保存的、并且可以被所有请求所使用的公共信息。
  无状态的服务器程序，最著名的就是WEB服务器。每次HTTP请求和以前都没有啥关系，只是获取目标URI。得到目标内容之后，这次连接就被杀死，没有任何痕迹。在后来的发展进程中，逐渐在无状态化的过程中，加入状态化的信息，比如COOKIE


systemctl服务的配置文件目录：/usr/lib/systemd/system/


Storage driver	                Supported backing filesystems
overlay2(推荐) overlay	        xfs with ftype=1, ext4
aufs(特殊指明/额外安装包)	    xfs, ext4
devicemapper	                direct-lvm
btrfs	                        btrfs
zfs	                            zfs
vfs	                            any filesystem


Enable IPv6 support
cat /etc/docker/daemon.json
{
  "ipv6": true
}
systemctl reload docker




docker and iptable:别手动添加规则到docker链中，如果需要添加，添加到DOCKER-USER链中，该链优先于docker链被加载
1.iptables -I DOCKER-USER -i ext_if ! -s 192.168.1.1 -j DROP         仅允许192.168.1.1地址访问
2.iptables -I DOCKER-USER -i ext_if ! -s 192.168.1.0/24 -j DROP      仅允许192.168.1.0/24地址访问
3.iptables -I DOCKER-USER -m iprange -i ext_if ! --src-range[--dst-range] 192.168.1.1-192.168.1.3 -j DROP


--hostname    常见容器的时候指定容器里的主机名
--dns         貌似没生效
--dns-search 
--dns-opt


Configure Docker to use a proxy server
  client:可以设置多个代理服务器
  cat ~/.docker/config.json
  {
   "proxies":
   {
     "default":
     {
       "httpProxy": "http://127.0.0.1:3001",
       "httpsProxy": "http://127.0.0.1:3001",
       "noProxy": "*.test.example.com,.example2.com"
     }
   }
  }
  
  Use environment variables
  Variable	    Dockerfile example	                                 docker run Example
  HTTP_PROXY	ENV HTTP_PROXY "http://127.0.0.1:3001"	             --env HTTP_PROXY="http://127.0.0.1:3001"
  HTTPS_PROXY	ENV HTTPS_PROXY "https://127.0.0.1:3001"	         --env HTTPS_PROXY="https://127.0.0.1:3001"
  FTP_PROXY	    ENV FTP_PROXY "ftp://127.0.0.1:3001"	             --env FTP_PROXY="ftp://127.0.0.1:3001"
  NO_PROXY	    ENV NO_PROXY "*.test.example.com,.example2.com"	     --env NO_PROXY="*.test.example.com,.example2.com"






























